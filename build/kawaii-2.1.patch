diff --color -Naru uwufetch-2.1/fetch.c uwufetch-2.2/fetch.c
--- uwufetch-2.1/fetch.c	2023-02-13 15:38:44.000000000 +0300
+++ uwufetch-2.2/fetch.c	2025-09-13 20:12:35.176056523 +0300
@@ -14,7 +14,7 @@
  */
 
 #ifdef __APPLE__
-	#include <TargetConditionals.h> // for checking iOS
+  #include <TargetConditionals.h> // for checking iOS
 #endif
 #include <dirent.h>
 #include <stdio.h>
@@ -22,31 +22,31 @@
 #include <string.h>
 #include <unistd.h>
 #if defined(__APPLE__) || defined(__BSD__)
-	#include <sys/sysctl.h>
-	#if defined(__OPENBSD__)
-		#include <sys/time.h>
-	#else
-		#include <time.h>
-	#endif // defined(__OPENBSD__)
-#else		 // defined(__APPLE__) || defined(__BSD__)
-	#ifdef __BSD__
-	#else // defined(__BSD__) || defined(_WIN32)
-		#ifndef _WIN32
-			#ifndef __OPENBSD__
-				#include <sys/sysinfo.h>
-			#else	 // __OPENBSD__
-			#endif // __OPENBSD__
-		#else		 // _WIN32
-			#include <sysinfoapi.h>
-		#endif // _WIN32
-	#endif	 // defined(__BSD__) || defined(_WIN32)
-#endif		 // defined(__APPLE__) || defined(__BSD__)
-#ifndef _WIN32
-	#include <sys/ioctl.h>
-	#include <sys/utsname.h>
-	#include <pthread.h> // linux only right now
-#else									 // _WIN32
-	#include <windows.h>
+  #include <sys/sysctl.h>
+  #if defined(__OPENBSD__)
+    #include <sys/time.h>
+  #else
+    #include <time.h>
+  #endif // defined(__OPENBSD__)
+#else    // defined(__APPLE__) || defined(__BSD__)
+  #ifdef __BSD__
+  #else // defined(__BSD__) || defined(_WIN32)
+    #ifndef _WIN32
+      #ifndef __OPENBSD__
+        #include <sys/sysinfo.h>
+      #else  // __OPENBSD__
+      #endif // __OPENBSD__
+    #else    // _WIN32
+      #include <sysinfoapi.h>
+    #endif // _WIN32
+  #endif   // defined(__BSD__) || defined(_WIN32)
+#endif     // defined(__APPLE__) || defined(__BSD__)
+#ifndef _WIN32
+  #include <pthread.h> // linux only right now
+  #include <sys/ioctl.h>
+  #include <sys/utsname.h>
+#else // _WIN32
+  #include <windows.h>
 CONSOLE_SCREEN_BUFFER_INFO csbi;
 #endif // _WIN32
 
@@ -59,22 +59,22 @@
 #endif
 
 #ifndef PKGPATH
-	#ifdef __APPLE__
-		#define PKGPATH "/usr/local/bin/"
-	#else
-		#define PKGPATH "/usr/bin/"
-	#endif
+  #ifdef __APPLE__
+    #define PKGPATH "/usr/local/bin/"
+  #else
+    #define PKGPATH "/usr/bin/"
+  #endif
 #endif
 
 #ifdef __APPLE__
 // buffers where data fetched from sysctl are stored
-	#define CPUBUFFERLEN 128
+  #define CPUBUFFERLEN 128
 
 char cpu_buffer[CPUBUFFERLEN];
 size_t cpu_buffer_len = CPUBUFFERLEN;
 
 // Installed RAM
-int64_t mem_buffer		= 0;
+int64_t mem_buffer    = 0;
 size_t mem_buffer_len = sizeof(mem_buffer);
 
 // uptime
@@ -83,693 +83,693 @@
 #endif // __APPLE__
 
 struct package_manager {
-	char* command_path;
-	char* command_string; // command to get number of packages installed
-	char* pkgman_name;		// name of the package manager
+  char* command_path;
+  char* command_string; // command to get number of packages installed
+  char* pkgman_name;    // name of the package manager
 };
 
 // truncates the given string
 void truncate_str(char* string, int target_width) {
-	char arr[target_width];
-	for (int i = 0; i < target_width; i++) arr[i] = string[i];
-	string = arr;
+  char arr[target_width];
+  for (int i = 0; i < target_width; i++) arr[i] = string[i];
+  string = arr;
 }
 
 // remove square brackets (for gpu names)
 void remove_brackets(char* str) {
-	int i = 0, j = 0;
-	while (i < (int)strlen(str))
-		if (str[i] == '[' || str[i] == ']')
-			for (j = i; j < (int)strlen(str); j++) str[j] = str[j + 1];
-		else
-			i++;
+  int i = 0, j = 0;
+  while (i < (int)strlen(str))
+    if (str[i] == '[' || str[i] == ']')
+      for (j = i; j < (int)strlen(str); j++) str[j] = str[j + 1];
+    else
+      i++;
 }
 
 void get_twidth(struct info* user_info) {
-	LOG_I("getting terminal width");
-	// get terminal width used to truncate long names
+  LOG_I("getting terminal width");
+  // get terminal width used to truncate long names
 #ifndef _WIN32
-	ioctl(STDOUT_FILENO, TIOCGWINSZ, &user_info->win);
-	user_info->target_width = user_info->win.ws_col - 30;
-	LOG_V(user_info->target_width);
-#else	 // _WIN32
-	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
-	user_info->ws_col	 = csbi.srWindow.Right - csbi.srWindow.Left - 29;
-	user_info->ws_rows = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
-	LOG_V(user_info->ws_col);
-	LOG_V(user_info->ws_rows);
+  ioctl(STDOUT_FILENO, TIOCGWINSZ, &user_info->win);
+  user_info->target_width = user_info->win.ws_col - 30;
+  LOG_V(user_info->target_width);
+#else  // _WIN32
+  GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &csbi);
+  user_info->ws_col  = csbi.srWindow.Right - csbi.srWindow.Left - 29;
+  user_info->ws_rows = csbi.srWindow.Bottom - csbi.srWindow.Top + 1;
+  LOG_V(user_info->ws_col);
+  LOG_V(user_info->ws_rows);
 #endif // _WIN32
 }
 
 void get_sys(struct info* user_info) {
-	LOG_I("getting sys_var struct");
+  LOG_I("getting sys_var struct");
 #ifndef _WIN32
-	uname(&user_info->sys_var);
+  uname(&user_info->sys_var);
 #endif // _WIN32
 #ifndef __APPLE__
-	#ifndef __BSD__
-		#ifndef _WIN32
-	sysinfo(&user_info->sys);
-		#else
-	GetSystemInfo(&user_info->sys);
-		#endif
-	#endif
+  #ifndef __BSD__
+    #ifndef _WIN32
+  sysinfo(&user_info->sys);
+    #else
+  GetSystemInfo(&user_info->sys);
+    #endif
+  #endif
 #endif
 }
 
 // tries to get cpu name
 void* get_cpu(void* argp) {
-	if (!((struct thread_varg*)argp)->thread_flags[0]) return 0;
-	char* buffer					 = ((struct thread_varg*)argp)->buffer;
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
-	FILE* cpuinfo					 = ((struct thread_varg*)argp)->cpuinfo;
-	LOG_I("getting cpu name");
-	if (cpuinfo) {
-		while (fgets(buffer, BUFFER_SIZE, cpuinfo)) {
+  if (!((struct thread_varg*)argp)->thread_flags[0]) return 0;
+  char* buffer           = ((struct thread_varg*)argp)->buffer;
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
+  FILE* cpuinfo          = ((struct thread_varg*)argp)->cpuinfo;
+  LOG_I("getting cpu name");
+  if (cpuinfo) {
+    while (fgets(buffer, BUFFER_SIZE, cpuinfo)) {
 #ifdef __BSD__
-			if (sscanf(buffer, "hw.model"
-	#ifdef __FREEBSD__
-												 ": "
-	#elif defined(__OPENBSD__)
-												 "="
-	#endif
-												 "%[^\n]",
-								 user_info->cpu_model))
-				break;
+      if (sscanf(buffer, "hw.model"
+  #ifdef __FREEBSD__
+                         ": "
+  #elif defined(__OPENBSD__)
+                         "="
+  #endif
+                         "%[^\n]",
+                 user_info->cpu_model))
+        break;
 #else
-			if (sscanf(buffer, "model name    : %[^\n]", user_info->cpu_model)) break;
+      if (sscanf(buffer, "model name    : %[^\n]", user_info->cpu_model)) break;
 #endif // __BSD__
-		}
-	}
-	if (strlen(user_info->cpu_model) == 0) {
-		LOG_E("failed to get cpu name");
-		rewind(cpuinfo);
-		char cores[4] = "";
-		while (fgets(buffer, BUFFER_SIZE, cpuinfo)) // get the last core number
-			sscanf(buffer, "processor%*[    |	]: %[^\n]", cores);
-		cores[strlen(cores) - 1] += 1; // should be a number
-		sprintf(user_info->cpu_model, "%s Cores", cores);
-	}
-	LOG_V(user_info->cpu_model);
-	return 0;
+    }
+  }
+  if (strlen(user_info->cpu_model) == 0) {
+    LOG_E("failed to get cpu name");
+    rewind(cpuinfo);
+    char cores[4] = "";
+    while (fgets(buffer, BUFFER_SIZE, cpuinfo)) // get the last core number
+      sscanf(buffer, "processor%*[    |	]: %[^\n]", cores);
+    cores[strlen(cores) - 1] += 1; // should be a number
+    sprintf(user_info->cpu_model, "%s Cores", cores);
+  }
+  LOG_V(user_info->cpu_model);
+  return 0;
 }
 
 // tries to get memory usage
 void* get_ram(void* argp) {
-	if (!((struct thread_varg*)argp)->thread_flags[1]) return 0;
-	LOG_I("getting ram");
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
+  if (!((struct thread_varg*)argp)->thread_flags[1]) return 0;
+  LOG_I("getting ram");
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
 #ifndef __APPLE__
-	#ifdef _WIN32
-	FILE* mem_used_fp			 = popen("wmic os get freevirtualmemory", "r");			 // free memory
-	FILE* mem_total_fp		 = popen("wmic os get totalvirtualmemorysize", "r"); // total memory
-	char mem_used_ch[2137] = {0}, mem_total_ch[2137] = {0};
-
-	while (fgets(mem_total_ch, sizeof(mem_total_ch), mem_total_fp) != NULL) {
-		if (strstr(mem_total_ch, "TotalVirtualMemorySize") != 0)
-			continue;
-		else if (strstr(mem_total_ch, "  ") == 0)
-			continue;
-		else
-			user_info->ram_total = atoi(mem_total_ch) / 1024;
-	}
-	LOG_V(user_info->ram_total);
-	while (fgets(mem_used_ch, sizeof(mem_used_ch), mem_used_fp) != NULL) {
-		if (strstr(mem_used_ch, "FreeVirtualMemory") != 0)
-			continue;
-		else if (strstr(mem_used_ch, "  ") == 0)
-			continue;
-		else
-			user_info->ram_used = user_info->ram_total - (atoi(mem_used_ch) / 1024);
-	}
-	LOG_V(user_info->ram_used);
-	pclose(mem_used_fp);
-	pclose(mem_total_fp);
-	#else // if not _WIN32
-	char* buffer = ((struct thread_varg*)argp)->buffer;
-	FILE* meminfo;
-
-		#ifdef __BSD__
-			#ifndef __OPENBSD__
-	meminfo = popen("LANG=EN_us freecolor -om 2> /dev/null", "r"); // free alternative for freebsd
-			#else
-	meminfo = popen("LANG=EN_us vmstat 2> /dev/null | grep -v 'procs' | grep -v 'r' | awk '{print $3 "
-									"\" / \" $4}'",
-									"r"); // free alternative for openbsd
-			#endif
-		#else
-	// getting memory info from /proc/meminfo: https://github.com/KittyKatt/screenFetch/issues/386#issuecomment-249312716
-	meminfo = fopen("/proc/meminfo",
-									"r"); // popen("LANG=EN_us free -m 2> /dev/null", "r"); // get ram info with free
-		#endif
-	// brackets are here to restrict the access to this int variables, which are temporary
-	{
-		#ifndef __OPENBSD__
-		int memtotal = 0, shmem = 0, memfree = 0, buffers = 0, cached = 0, sreclaimable = 0;
-		#endif
-		while (fgets(buffer, BUFFER_SIZE, meminfo)) {
-		#ifndef __OPENBSD__
-			sscanf(buffer, "MemTotal:       %d", &memtotal);
-			sscanf(buffer, "Shmem:             %d", &shmem);
-			sscanf(buffer, "MemFree:        %d", &memfree);
-			sscanf(buffer, "Buffers:          %d", &buffers);
-			sscanf(buffer, "Cached:          %d", &cached);
-			sscanf(buffer, "SReclaimable:     %d", &sreclaimable);
-		#else
-			sscanf(buffer, "%dM / %dM", &user_info->ram_used, &user_info->ram_total);
-		#endif
-		}
-		#ifndef __OPENBSD__
-		user_info->ram_total = memtotal / 1024;
-		user_info->ram_used = ((memtotal + shmem) - (memfree + buffers + cached + sreclaimable)) / 1024;
-		#endif
-		LOG_V(user_info->ram_total);
-		LOG_V(user_info->ram_used);
-	}
+  #ifdef _WIN32
+  FILE* mem_used_fp      = popen("wmic os get freevirtualmemory", "r");      // free memory
+  FILE* mem_total_fp     = popen("wmic os get totalvirtualmemorysize", "r"); // total memory
+  char mem_used_ch[2137] = {0}, mem_total_ch[2137] = {0};
+
+  while (fgets(mem_total_ch, sizeof(mem_total_ch), mem_total_fp) != NULL) {
+    if (strstr(mem_total_ch, "TotalVirtualMemorySize") != 0)
+      continue;
+    else if (strstr(mem_total_ch, "  ") == 0)
+      continue;
+    else
+      user_info->ram_total = atoi(mem_total_ch) / 1024;
+  }
+  LOG_V(user_info->ram_total);
+  while (fgets(mem_used_ch, sizeof(mem_used_ch), mem_used_fp) != NULL) {
+    if (strstr(mem_used_ch, "FreeVirtualMemory") != 0)
+      continue;
+    else if (strstr(mem_used_ch, "  ") == 0)
+      continue;
+    else
+      user_info->ram_used = user_info->ram_total - (atoi(mem_used_ch) / 1024);
+  }
+  LOG_V(user_info->ram_used);
+  pclose(mem_used_fp);
+  pclose(mem_total_fp);
+  #else // if not _WIN32
+  char* buffer = ((struct thread_varg*)argp)->buffer;
+  FILE* meminfo;
+
+    #ifdef __BSD__
+      #ifndef __OPENBSD__
+  meminfo = popen("LANG=EN_us freecolor -om 2> /dev/null", "r"); // free alternative for freebsd
+      #else
+  meminfo = popen("LANG=EN_us vmstat 2> /dev/null | grep -v 'procs' | grep -v 'r' | awk '{print $3 "
+                  "\" / \" $4}'",
+                  "r"); // free alternative for openbsd
+      #endif
+    #else
+  // getting memory info from /proc/meminfo: https://github.com/KittyKatt/screenFetch/issues/386#issuecomment-249312716
+  meminfo = fopen("/proc/meminfo",
+                  "r"); // popen("LANG=EN_us free -m 2> /dev/null", "r"); // get ram info with free
+    #endif
+  // brackets are here to restrict the access to this int variables, which are temporary
+  {
+    #ifndef __OPENBSD__
+    int memtotal = 0, shmem = 0, memfree = 0, buffers = 0, cached = 0, sreclaimable = 0;
+    #endif
+    while (fgets(buffer, BUFFER_SIZE, meminfo)) {
+    #ifndef __OPENBSD__
+      sscanf(buffer, "MemTotal:       %d", &memtotal);
+      sscanf(buffer, "Shmem:             %d", &shmem);
+      sscanf(buffer, "MemFree:        %d", &memfree);
+      sscanf(buffer, "Buffers:          %d", &buffers);
+      sscanf(buffer, "Cached:          %d", &cached);
+      sscanf(buffer, "SReclaimable:     %d", &sreclaimable);
+    #else
+      sscanf(buffer, "%dM / %dM", &user_info->ram_used, &user_info->ram_total);
+    #endif
+    }
+    #ifndef __OPENBSD__
+    user_info->ram_total = memtotal / 1024;
+    user_info->ram_used = ((memtotal + shmem) - (memfree + buffers + cached + sreclaimable)) / 1024;
+    #endif
+    LOG_V(user_info->ram_total);
+    LOG_V(user_info->ram_used);
+  }
 
-	fclose(meminfo);
-	#endif
+  fclose(meminfo);
+  #endif
 #else // if __APPLE__
-	// Used
-	FILE *mem_wired_fp, *mem_active_fp, *mem_compressed_fp;
-	mem_wired_fp			= popen("vm_stat | awk '/wired/ { printf $4 }' | cut -d '.' -f 1", "r");
-	mem_active_fp			= popen("vm_stat | awk '/active/ { printf $3 }' | cut -d '.' -f 1", "r");
-	mem_compressed_fp = popen("vm_stat | awk '/occupied/ { printf $5 }' | cut -d '.' -f 1", "r");
-	char mem_wired_ch[2137], mem_active_ch[2137], mem_compressed_ch[2137];
-	while (fgets(mem_wired_ch, sizeof(mem_wired_ch), mem_wired_fp) != NULL)
-		while (fgets(mem_active_ch, sizeof(mem_active_ch), mem_active_fp) != NULL)
-			while (fgets(mem_compressed_ch, sizeof(mem_compressed_ch), mem_compressed_fp) != NULL)
-				;
-
-	pclose(mem_wired_fp);
-	pclose(mem_active_fp);
-	pclose(mem_compressed_fp);
-
-	int mem_wired			 = atoi(mem_wired_ch);
-	int mem_active		 = atoi(mem_active_ch);
-	int mem_compressed = atoi(mem_compressed_ch);
-
-	// Total
-	sysctlbyname("hw.memsize", &mem_buffer, &mem_buffer_len, NULL, 0);
-	user_info->ram_used	 = ((mem_wired + mem_active + mem_compressed) * 4 / 1024);
-	user_info->ram_total = mem_buffer / 1024 / 1024;
-	LOG_V(user_info->ram_total);
-	LOG_V(user_info->ram_used);
+  // Used
+  FILE *mem_wired_fp, *mem_active_fp, *mem_compressed_fp;
+  mem_wired_fp      = popen("vm_stat | awk '/wired/ { printf $4 }' | cut -d '.' -f 1", "r");
+  mem_active_fp     = popen("vm_stat | awk '/active/ { printf $3 }' | cut -d '.' -f 1", "r");
+  mem_compressed_fp = popen("vm_stat | awk '/occupied/ { printf $5 }' | cut -d '.' -f 1", "r");
+  char mem_wired_ch[2137], mem_active_ch[2137], mem_compressed_ch[2137];
+  while (fgets(mem_wired_ch, sizeof(mem_wired_ch), mem_wired_fp) != NULL)
+    while (fgets(mem_active_ch, sizeof(mem_active_ch), mem_active_fp) != NULL)
+      while (fgets(mem_compressed_ch, sizeof(mem_compressed_ch), mem_compressed_fp) != NULL)
+        ;
+
+  pclose(mem_wired_fp);
+  pclose(mem_active_fp);
+  pclose(mem_compressed_fp);
+
+  int mem_wired      = atoi(mem_wired_ch);
+  int mem_active     = atoi(mem_active_ch);
+  int mem_compressed = atoi(mem_compressed_ch);
+
+  // Total
+  sysctlbyname("hw.memsize", &mem_buffer, &mem_buffer_len, NULL, 0);
+  user_info->ram_used  = ((mem_wired + mem_active + mem_compressed) * 4 / 1024);
+  user_info->ram_total = mem_buffer / 1024 / 1024;
+  LOG_V(user_info->ram_total);
+  LOG_V(user_info->ram_used);
 #endif
-	return 0;
+  return 0;
 }
 
 // tries to get installed gpu(s)
 void* get_gpu(void* argp) {
-	if (!((struct thread_varg*)argp)->thread_flags[2]) return 0;
-	char* buffer					 = ((struct thread_varg*)argp)->buffer;
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
-	int gpuc							 = 0; // gpu counter
+  if (!((struct thread_varg*)argp)->thread_flags[2]) return 0;
+  LOG_I("getting gpu(s)");
+  char* buffer           = ((struct thread_varg*)argp)->buffer;
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
+  int gpuc               = 0; // gpu counter
 #ifndef _WIN32
-	setenv("LANG", "en_US", 1); // force language to english
+  setenv("LANG", "en_US", 1); // force language to english
 #endif
-	FILE* gpu;
+  FILE* gpu;
 #ifndef _WIN32
-	LOG_I("getting gpus with lshw");
-	gpu = popen("lshw -class display 2> /dev/null", "r");
+  LOG_I("getting gpus with lshw");
+  gpu = popen("lshw -class display 2> /dev/null", "r");
 
-	// add all gpus to the array gpu_model
-	while (fgets(buffer, BUFFER_SIZE, gpu))
-		if (sscanf(buffer, "    product: %[^\n]", user_info->gpu_model[gpuc])) gpuc++;
+  // add all gpus to the array gpu_model
+  while (fgets(buffer, BUFFER_SIZE, gpu))
+    if (sscanf(buffer, "    product: %[^\n]", user_info->gpu_model[gpuc])) gpuc++;
 #endif
 
-	if (strlen(user_info->gpu_model[0]) < 2) {
-		// get gpus with lspci command
-		if (strcmp(user_info->os_name, "android") != 0) {
+  if (strlen(user_info->gpu_model[0]) < 2) {
+    // get gpus with lspci command
+    if (strcmp(user_info->os_name, "android") != 0) {
 #ifndef __APPLE__
-	#ifdef _WIN32
-			gpu = popen("wmic PATH Win32_VideoController GET Name", "r");
-	#else
-			gpu = popen("lspci -mm 2> /dev/null | grep \"VGA\" | awk -F '\"' '{print $4 $5 $6}'", "r");
-	#endif
+  #ifdef _WIN32
+      gpu = popen("wmic PATH Win32_VideoController GET Name", "r");
+  #else
+      gpu = popen("lspci -mm 2> /dev/null | grep \"VGA\" | awk -F '\"' '{print $4 $5 $6}'", "r");
+  #endif
 #else
-			gpu = popen(
-					"system_profiler SPDisplaysDataType | awk -F ': ' '/Chipset Model: /{ print $2 }'", "r");
+      gpu = popen(
+          "system_profiler SPDisplaysDataType | awk -F ': ' '/Chipset Model: /{ print $2 }'", "r");
 #endif
-		} else
-			gpu = popen("getprop ro.hardware.vulkan 2> /dev/null", "r"); // for android
-	}
-
-	// get all the gpus
-	while (fgets(buffer, BUFFER_SIZE, gpu)) {
-		// windows
-		if (strstr(buffer, "Name") || (strlen(buffer) == 2))
-			continue;
-		else if (sscanf(buffer, "%[^\n]", user_info->gpu_model[gpuc]))
-			gpuc++;
-	}
-	fclose(gpu);
-
-	// format gpu names
-	for (int i = 0; i < gpuc; i++) {
-		remove_brackets(user_info->gpu_model[i]);
-		truncate_str(user_info->gpu_model[i], user_info->target_width);
-		LOG_V(user_info->gpu_model[i]);
-	}
-	return 0;
+    } else
+      gpu = popen("getprop ro.hardware.vulkan 2> /dev/null", "r"); // for android
+  }
+
+  // get all the gpus
+  while (fgets(buffer, BUFFER_SIZE, gpu)) {
+    // windows
+    if (strstr(buffer, "Name") || (strlen(buffer) == 2))
+      continue;
+    else if (sscanf(buffer, "%[^\n]", user_info->gpu_model[gpuc]))
+      gpuc++;
+  }
+  fclose(gpu);
+
+  // format gpu names
+  for (int i = 0; i < gpuc; i++) {
+    remove_brackets(user_info->gpu_model[i]);
+    truncate_str(user_info->gpu_model[i], user_info->target_width);
+    LOG_V(user_info->gpu_model[i]);
+  }
+  return 0;
 }
 
 // tries to get screen resolution
 #ifndef _WIN32
 void* get_res(void* argp) {
-	if (!((struct thread_varg*)argp)->thread_flags[3]) return 0;
-	LOG_I("getting resolution");
-	char* buffer					 = ((struct thread_varg*)argp)->buffer;
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
-	FILE* resolution			 = popen("xwininfo -root 2> /dev/null | grep -E 'Width|Height'", "r");
-	while (fgets(buffer, BUFFER_SIZE, resolution)) {
-		sscanf(buffer, "  Width: %d", &user_info->screen_width);
-		sscanf(buffer, "  Height: %d", &user_info->screen_height);
-	}
-	LOG_V(user_info->screen_width);
-	LOG_V(user_info->screen_height);
+  if (!((struct thread_varg*)argp)->thread_flags[3]) return 0;
+  LOG_I("getting resolution");
+  char* buffer           = ((struct thread_varg*)argp)->buffer;
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
+  FILE* resolution       = popen("xwininfo -root 2> /dev/null | grep -E 'Width|Height'", "r");
+  while (fgets(buffer, BUFFER_SIZE, resolution)) {
+    sscanf(buffer, "  Width: %d", &user_info->screen_width);
+    sscanf(buffer, "  Height: %d", &user_info->screen_height);
+  }
+  LOG_V(user_info->screen_width);
+  LOG_V(user_info->screen_height);
 #else
 void* get_res() {
-	// TODO: get resolution on windows
+  // TODO: get resolution on windows
 #endif
-	return 0;
+  return 0;
 }
 
 // tries to get the installed package count and package managers name
 void* get_pkg(void* argp) { // this is just a function that returns the total of installed packages
-	if (!((struct thread_varg*)argp)->thread_flags[4]) return 0;
-	LOG_I("getting pkgs");
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
-	user_info->pkgs				 = 0;
+  if (!((struct thread_varg*)argp)->thread_flags[4]) return 0;
+  LOG_I("getting pkgs");
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
+  user_info->pkgs        = 0;
 #ifndef __APPLE__
-	#ifndef _WIN32
-	// all supported package managers
-	struct package_manager pkgmans[] = {
-			{PKGPATH "apt", "apt list --installed 2> /dev/null | wc -l", "(apt)"},
-			{PKGPATH "apk", "apk info 2> /dev/null | wc -l", "(apk)"},
-			// {PKGPATH"dnf","dnf list installed 2> /dev/null | wc -l", "(dnf)"}, // according to https://stackoverflow.com/questions/48570019/advantages-of-dnf-vs-rpm-on-fedora, dnf and rpm return the same number of packages
-			{PKGPATH "qlist", "qlist -I 2> /dev/null | wc -l", "(emerge)"},
-			{PKGPATH "flatpak", "flatpak list 2> /dev/null | wc -l", "(flatpak)"},
-			{PKGPATH "snap", "snap list 2> /dev/null | wc -l", "(snap)"},
-			{PKGPATH "guix", "guix package --list-installed 2> /dev/null | wc -l", "(guix)"},
-			{PKGPATH "nix-store", "nix-store -q --requisites /run/current-system/sw 2> /dev/null | wc -l", "(nix)"},
-			{PKGPATH "pacman", "pacman -Qq 2> /dev/null | wc -l", "(pacman)"},
-			{PKGPATH "pkg", "pkg info 2>/dev/null | wc -l", "(pkg)"},
-			{PKGPATH "pkg_info", "pkg_info 2>/dev/null | wc -l | sed \"s/ //g\"", "(pkg)"},
-			{PKGPATH "port", "port installed 2> /dev/null | tail -n +2 | wc -l", "(port)"},
-			{PKGPATH "brew", "find $(brew --cellar 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}'", "(brew-cellar)"},
-			{PKGPATH "brew", "find $(brew --caskroom 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}'", "(brew-cask)"},
-			{PKGPATH "rpm", "rpm -qa --last 2> /dev/null | wc -l", "(rpm)"},
-			{PKGPATH "xbps-query", "xbps-query -l 2> /dev/null | wc -l", "(xbps)"},
-			{PKGPATH "zypper", "zypper -q se --installed-only 2> /dev/null | wc -l", "(zypper)"}};
-	#endif
+  #ifndef _WIN32
+  // all supported package managers
+  struct package_manager pkgmans[] = {
+      {PKGPATH "apt", "apt list --installed 2> /dev/null | wc -l", "(apt)"},
+      {PKGPATH "apk", "apk info 2> /dev/null | wc -l", "(apk)"},
+      // {PKGPATH"dnf","dnf list installed 2> /dev/null | wc -l", "(dnf)"}, // according to https://stackoverflow.com/questions/48570019/advantages-of-dnf-vs-rpm-on-fedora, dnf and rpm return the same number of packages
+      {PKGPATH "qlist", "qlist -I 2> /dev/null | wc -l", "(emerge)"},
+      {PKGPATH "flatpak", "flatpak list 2> /dev/null | wc -l", "(flatpak)"},
+      {PKGPATH "snap", "snap list 2> /dev/null | wc -l", "(snap)"},
+      {PKGPATH "guix", "guix package --list-installed 2> /dev/null | wc -l", "(guix)"},
+      {PKGPATH "nix-store", "nix-store -q --requisites /run/current-system/sw 2> /dev/null | wc -l", "(nix)"},
+      {PKGPATH "pacman", "pacman -Qq 2> /dev/null | wc -l", "(pacman)"},
+      {PKGPATH "pkg", "pkg info 2>/dev/null | wc -l", "(pkg)"},
+      {PKGPATH "pkg_info", "pkg_info 2>/dev/null | wc -l | sed \"s/ //g\"", "(pkg)"},
+      {PKGPATH "port", "port installed 2> /dev/null | tail -n +2 | wc -l", "(port)"},
+      {PKGPATH "brew", "find $(brew --cellar 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}'", "(brew-cellar)"},
+      {PKGPATH "brew", "find $(brew --caskroom 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}'", "(brew-cask)"},
+      {PKGPATH "rpm", "rpm -qa --last 2> /dev/null | wc -l", "(rpm)"},
+      {PKGPATH "xbps-query", "xbps-query -l 2> /dev/null | wc -l", "(xbps)"}};
+  #endif
 #else
-	struct package_manager pkgmans[] = {{"/usr/local/bin/brew", "find $(brew --cellar 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}' > /tmp/uwufetch_brew_tmp", "(brew-cellar)"},
-																			{"/usr/local/bin/brew", "find $(brew --caskroom 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}' > /tmp/uwufetch_brew_tmp", "(brew-cask)"}};
+  struct package_manager pkgmans[] = {{"/usr/local/bin/brew", "find $(brew --cellar 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}' > /tmp/uwufetch_brew_tmp", "(brew-cellar)"},
+                                      {"/usr/local/bin/brew", "find $(brew --caskroom 2>/dev/stdout) -maxdepth 1 -type d 2> /dev/null | wc -l | awk '{print $1}' > /tmp/uwufetch_brew_tmp", "(brew-cask)"}};
 #endif
 #ifndef _WIN32
-	const int pkgman_count = sizeof(pkgmans) / sizeof(pkgmans[0]); // number of package managers
-	int comma_separator		 = 0;
-	for (int i = 0; i < pkgman_count; i++) {
-		struct package_manager* current = &pkgmans[i]; // pointer to current package manager
-
-		unsigned int pkg_count = 0;
-		LOG_I("trying pkgman %d: %s", i, current->pkgman_name);
-		LOG_V(current->command_path);
-		if (access(current->command_path, F_OK) != -1) {
-	#ifndef __APPLE__
-			FILE* fp = popen(current->command_string, "r"); // trying current package manager
-	#else
-			system(current->command_string); // writes to a temporary file: for some reason popen() does not intercept the stdout, so i have to read from a temporary file
-			FILE* fp = fopen("/tmp/uwufetch_brew_tmp", "r");
-	#endif
-			if (fscanf(fp, "%u", &pkg_count) == 3) continue;
-
-	#ifndef __APPLE__
-			pclose(fp);
-	#else
-			// remove("/tmp/uwufetch_brew_tmp");
-			fclose(fp);
-	#endif
-		}
-	#ifdef __DEBUG__
-		else
-			LOG_W("pkgman %s executable not found!", current->pkgman_name);
-	#endif
-
-		// adding a package manager with its package count to user_info->pkgman_name
-		user_info->pkgs += pkg_count;
-		if (pkg_count > 0) {
-			if (comma_separator++) strcat(user_info->pkgman_name, ", ");
-			char spkg_count[16];
-			sprintf(spkg_count, "%u", pkg_count);
-			strcat(user_info->pkgman_name, spkg_count);
-			strcat(user_info->pkgman_name, " ");
-			strcat(user_info->pkgman_name, current->pkgman_name);
-			LOG_V(user_info->pkgman_name);
-		}
-	}
-#else	 // _WIN32
-	// chocolatey for windows
-	FILE* fp = popen("choco list -l --no-color 2> nul", "r");
-	unsigned int pkg_count;
-	char buffer[7562] = {0};
-	while (fgets(buffer, BUFFER_SIZE, fp)) {
-		sscanf(buffer, "%u packages installed.", &pkg_count);
-	}
-	if (fp) pclose(fp);
-
-	user_info->pkgs = pkg_count;
-	char spkg_count[16];
-	sprintf(spkg_count, "%u", pkg_count);
-	strcat(user_info->pkgman_name, spkg_count);
-	strcat(user_info->pkgman_name, " ");
-	strcat(user_info->pkgman_name, "(chocolatey)");
-	LOG_V(user_info->pkgman_name);
+  const int pkgman_count = sizeof(pkgmans) / sizeof(pkgmans[0]); // number of package managers
+  int comma_separator    = 0;
+  for (int i = 0; i < pkgman_count; i++) {
+    struct package_manager* current = &pkgmans[i]; // pointer to current package manager
+
+    unsigned int pkg_count = 0;
+    LOG_I("trying pkgman %d: %s", i, current->pkgman_name);
+    LOG_V(current->command_path);
+    if (access(current->command_path, F_OK) != -1) {
+  #ifndef __APPLE__
+      FILE* fp = popen(current->command_string, "r"); // trying current package manager
+  #else
+      system(current->command_string); // writes to a temporary file: for some reason popen() does not intercept the stdout, so i have to read from a temporary file
+      FILE* fp = fopen("/tmp/uwufetch_brew_tmp", "r");
+  #endif
+      if (fscanf(fp, "%u", &pkg_count) == 3) continue;
+
+  #ifndef __APPLE__
+      pclose(fp);
+  #else
+      // remove("/tmp/uwufetch_brew_tmp");
+      fclose(fp);
+  #endif
+    }
+  #ifdef __DEBUG__
+    else
+      LOG_W("pkgman %s executable not found!", current->pkgman_name);
+  #endif
+
+    // adding a package manager with its package count to user_info->pkgman_name
+    user_info->pkgs += pkg_count;
+    if (pkg_count > 0) {
+      if (comma_separator++) strcat(user_info->pkgman_name, ", ");
+      char spkg_count[16];
+      sprintf(spkg_count, "%u", pkg_count);
+      strcat(user_info->pkgman_name, spkg_count);
+      strcat(user_info->pkgman_name, " ");
+      strcat(user_info->pkgman_name, current->pkgman_name);
+      LOG_V(user_info->pkgman_name);
+    }
+  }
+#else  // _WIN32
+  // chocolatey for windows
+  FILE* fp = popen("choco list -l --no-color 2> nul", "r");
+  unsigned int pkg_count;
+  char buffer[7562] = {0};
+  while (fgets(buffer, BUFFER_SIZE, fp)) {
+    sscanf(buffer, "%u packages installed.", &pkg_count);
+  }
+  if (fp) pclose(fp);
+
+  user_info->pkgs = pkg_count;
+  char spkg_count[16];
+  sprintf(spkg_count, "%u", pkg_count);
+  strcat(user_info->pkgman_name, spkg_count);
+  strcat(user_info->pkgman_name, " ");
+  strcat(user_info->pkgman_name, "(chocolatey)");
+  LOG_V(user_info->pkgman_name);
 #endif // _WIN32
-	return 0;
+  return 0;
 }
 
 void* get_model(void* argp) {
-	if (!((struct thread_varg*)argp)->thread_flags[5]) return 0;
-	LOG_I("getting model");
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
-	char* buffer					 = ((struct thread_varg*)argp)->buffer;
-	FILE* model_fp;
+  if (!((struct thread_varg*)argp)->thread_flags[5]) return 0;
+  LOG_I("getting model");
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
+  char* buffer           = ((struct thread_varg*)argp)->buffer;
+  FILE* model_fp;
 #ifdef _WIN32
-	// all the previous files obviously did not exist on windows
-	model_fp = popen("wmic computersystem get model", "r");
-	while (fgets(buffer, BUFFER_SIZE, model_fp)) {
-		if (strstr(buffer, "Model") != 0)
-			continue;
-		else {
-			sprintf(user_info->model, "%s", buffer);
-			user_info->model[strlen(user_info->model) - 2] = '\0';
-			break;
-		}
-	}
+  // all the previous files obviously did not exist on windows
+  model_fp = popen("wmic computersystem get model", "r");
+  while (fgets(buffer, BUFFER_SIZE, model_fp)) {
+    if (strstr(buffer, "Model") != 0)
+      continue;
+    else {
+      sprintf(user_info->model, "%s", buffer);
+      user_info->model[strlen(user_info->model) - 2] = '\0';
+      break;
+    }
+  }
 #elif defined(__BSD__) || defined(__APPLE__)
-	#if defined(__BSD__) && !defined(__OPENBSD__)
-		#define HOSTCTL "hw.hv_vendor"
-	#elif defined(__APPLE__)
-		#define HOSTCTL "hw.model"
-	#elif defined(__OPENBSD__)
-		#define HOSTCTL "hw.product"
-	#endif
-	model_fp = popen("sysctl " HOSTCTL, "r");
-	while (fgets(buffer, BUFFER_SIZE, model_fp))
-		if (sscanf(buffer,
-							 HOSTCTL
-	#ifdef __OPENBSD__
-							 "="
-	#else
-							 ": "
-	#endif
-							 "%[^\n]",
-							 user_info->model))
-			break;
-	pclose(model_fp);
+  #if defined(__BSD__) && !defined(__OPENBSD__)
+    #define HOSTCTL "hw.hv_vendor"
+  #elif defined(__APPLE__)
+    #define HOSTCTL "hw.model"
+  #elif defined(__OPENBSD__)
+    #define HOSTCTL "hw.product"
+  #endif
+  model_fp = popen("sysctl " HOSTCTL, "r");
+  while (fgets(buffer, BUFFER_SIZE, model_fp))
+    if (sscanf(buffer,
+               HOSTCTL
+  #ifdef __OPENBSD__
+               "="
+  #else
+               ": "
+  #endif
+               "%[^\n]",
+               user_info->model))
+      break;
+  pclose(model_fp);
 #else
-	char model_filename[4][256] = {
-			"/sys/devices/virtual/dmi/id/product_version",
-			"/sys/devices/virtual/dmi/id/product_name",
-			"/sys/devices/virtual/dmi/id/board_name",
-			"getprop ro.product.vendor.marketname 2>/dev/null",
-	};
-
-	char tmp_model[4][BUFFER_SIZE] = {0}; // temporary variable to store the contents of all 3 files
-	int longest_model = 0, best_len = 0, currentlen = 0;
-	FILE* (*tocall[])(const char*, const char*) = {fopen, fopen, fopen, popen}; // open a process or a file, depending on the model_filename
-	int (*tocall_close[])(FILE*)								= {fclose, fclose, fclose, pclose};
-	for (int i = 0; i < 4; i++) {
-		// read file
-		model_fp = tocall[i](model_filename[i], "r");
-		if (model_fp) {
-			fgets(tmp_model[i], BUFFER_SIZE, model_fp);
-			tmp_model[i][strlen(tmp_model[i]) - 1] = '\0';
-			tocall_close[i](model_fp);
-		}
-		LOG_V(tmp_model[i]);
-		// choose the file with the longest name
-		currentlen = strlen(tmp_model[i]);
-		if (currentlen > best_len) {
-			best_len			= currentlen;
-			longest_model = i;
-		}
-	}
-	if (strlen(tmp_model[longest_model]) == 0) {
-		model_fp = popen("lscpu 2>/dev/null", "r");
-		while (fgets(buffer, BUFFER_SIZE, model_fp))
-			if (sscanf(buffer, "Model name:%*[           |		]%[^\n]", tmp_model[longest_model]) == 1) break;
-		pclose(model_fp);
-		LOG_V(tmp_model[longest_model]);
-		if (strcmp(tmp_model[longest_model], "Icestorm") == 0) sprintf(tmp_model[longest_model], "Apple MacBook Air (M1)");
-	}
-	sprintf(user_info->model, "%s", tmp_model[longest_model]);
-	LOG_V(user_info->model);
+  char model_filename[4][256] = {
+      "/sys/devices/virtual/dmi/id/product_version",
+      "/sys/devices/virtual/dmi/id/product_name",
+      "/sys/devices/virtual/dmi/id/board_name",
+      "getprop ro.product.vendor.marketname 2>/dev/null",
+  };
+
+  char tmp_model[4][BUFFER_SIZE] = {0}; // temporary variable to store the contents of all 3 files
+  int longest_model = 0, best_len = 0, currentlen = 0;
+  FILE* (*tocall[])(const char*, const char*) = {fopen, fopen, fopen, popen}; // open a process or a file, depending on the model_filename
+  int (*tocall_close[])(FILE*)                = {fclose, fclose, fclose, pclose};
+  for (int i = 0; i < 4; i++) {
+    // read file
+    model_fp = tocall[i](model_filename[i], "r");
+    if (model_fp) {
+      fgets(tmp_model[i], BUFFER_SIZE, model_fp);
+      tmp_model[i][strlen(tmp_model[i]) - 1] = '\0';
+      tocall_close[i](model_fp);
+    }
+    LOG_V(tmp_model[i]);
+    // choose the file with the longest name
+    currentlen = strlen(tmp_model[i]);
+    if (currentlen > best_len) {
+      best_len      = currentlen;
+      longest_model = i;
+    }
+  }
+  if (strlen(tmp_model[longest_model]) == 0) {
+    model_fp = popen("lscpu 2>/dev/null", "r");
+    while (fgets(buffer, BUFFER_SIZE, model_fp))
+      if (sscanf(buffer, "Model name:%*[           |		]%[^\n]", tmp_model[longest_model]) == 1) break;
+    pclose(model_fp);
+    LOG_V(tmp_model[longest_model]);
+    if (strcmp(tmp_model[longest_model], "Icestorm") == 0) sprintf(tmp_model[longest_model], "Apple MacBook Air (M1)");
+  }
+  sprintf(user_info->model, "%s", tmp_model[longest_model]);
+  LOG_V(user_info->model);
 #endif
-	return 0;
+  return 0;
 }
 
 void* get_ker(void* argp) {
-	if (!((struct thread_varg*)argp)->thread_flags[6]) return 0;
-	LOG_I("getting kernel");
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
-
-#ifndef _WIN32
-	truncate_str(user_info->sys_var.release, user_info->target_width);
-	sprintf(user_info->kernel, "%s %s %s", user_info->sys_var.sysname, user_info->sys_var.release, user_info->sys_var.machine); // kernel name
-	truncate_str(user_info->kernel, user_info->target_width);
-	LOG_V(user_info->kernel);
-#else	 // _WIN32
-	// windows version
-	FILE* kernel_fp = popen("wmic computersystem get systemtype", "r");
-	char* buffer		= ((struct thread_varg*)argp)->buffer;
-	while (fgets(buffer, BUFFER_SIZE, kernel_fp)) {
-		if (strstr(buffer, "SystemType") != 0)
-			continue;
-		else {
-			sprintf(user_info->kernel, "%s", buffer);
-			user_info->kernel[strlen(user_info->kernel) - 2] = '\0';
-			break;
-		}
-	}
-	if (kernel_fp) pclose(kernel_fp);
+  if (!((struct thread_varg*)argp)->thread_flags[6]) return 0;
+  LOG_I("getting kernel");
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
+
+#ifndef _WIN32
+  truncate_str(user_info->sys_var.release, user_info->target_width);
+  sprintf(user_info->kernel, "%s %s %s", user_info->sys_var.sysname, user_info->sys_var.release, user_info->sys_var.machine); // kernel name
+  truncate_str(user_info->kernel, user_info->target_width);
+  LOG_V(user_info->kernel);
+#else  // _WIN32
+  // windows version
+  FILE* kernel_fp = popen("wmic computersystem get systemtype", "r");
+  char* buffer    = ((struct thread_varg*)argp)->buffer;
+  while (fgets(buffer, BUFFER_SIZE, kernel_fp)) {
+    if (strstr(buffer, "SystemType") != 0)
+      continue;
+    else {
+      sprintf(user_info->kernel, "%s", buffer);
+      user_info->kernel[strlen(user_info->kernel) - 2] = '\0';
+      break;
+    }
+  }
+  if (kernel_fp) pclose(kernel_fp);
 #endif // _WIN32
-	return 0;
+  return 0;
 }
 
 void* get_upt(void* argp) {
-	LOG_V(((struct thread_varg*)argp)->thread_flags[7]);
-	if (!((struct thread_varg*)argp)->thread_flags[7]) return 0;
-	LOG_I("getting uptime");
-	struct info* user_info = ((struct thread_varg*)argp)->user_info;
+  LOG_V(((struct thread_varg*)argp)->thread_flags[7]);
+  if (!((struct thread_varg*)argp)->thread_flags[7]) return 0;
+  LOG_I("getting uptime");
+  struct info* user_info = ((struct thread_varg*)argp)->user_info;
 #ifdef __APPLE__
-	int mib[2] = {CTL_KERN, KERN_BOOTTIME};
-	sysctl(mib, 2, &time_buffer, &time_buffer_len, NULL, 0);
+  int mib[2] = {CTL_KERN, KERN_BOOTTIME};
+  sysctl(mib, 2, &time_buffer, &time_buffer_len, NULL, 0);
 
-	time_t bsec = time_buffer.tv_sec;
-	time_t csec = time(NULL);
+  time_t bsec = time_buffer.tv_sec;
+  time_t csec = time(NULL);
 
-	user_info->uptime = difftime(csec, bsec);
+  user_info->uptime = difftime(csec, bsec);
 #else
-	#ifdef __BSD__
-	// https://github.com/coreutils/coreutils/blob/master/src/uptime.c
-	int boot_time					= 0;
-	static int request[2] = {CTL_KERN, KERN_BOOTTIME};
-	struct timeval result;
-	size_t result_len = sizeof result;
-
-	if (sysctl(request, 2, &result, &result_len, NULL, 0) >= 0) boot_time = result.tv_sec;
-	int time_now			= time(NULL);
-	user_info->uptime = time_now - boot_time;
-	#else
-		#ifdef _WIN32
-	user_info->uptime = GetTickCount() / 1000;
-		#else	 // _WIN32
-	user_info->uptime = user_info->sys.uptime;
-		#endif // _WIN32
-	#endif
+  #ifdef __BSD__
+  // https://github.com/coreutils/coreutils/blob/master/src/uptime.c
+  int boot_time         = 0;
+  static int request[2] = {CTL_KERN, KERN_BOOTTIME};
+  struct timeval result;
+  size_t result_len = sizeof result;
+
+  if (sysctl(request, 2, &result, &result_len, NULL, 0) >= 0) boot_time = result.tv_sec;
+  int time_now      = time(NULL);
+  user_info->uptime = time_now - boot_time;
+  #else
+    #ifdef _WIN32
+  user_info->uptime = GetTickCount() / 1000;
+    #else  // _WIN32
+  user_info->uptime = user_info->sys.uptime;
+    #endif // _WIN32
+  #endif
 #endif
-	LOG_V(user_info->uptime);
-	return 0;
+  LOG_V(user_info->uptime);
+  return 0;
 }
 
 // Retrieves system information
 void get_info(struct flags flags, struct info* user_info) {
-	char buffer[BUFFER_SIZE]; // line buffer
-	get_twidth(user_info);
-	// os version, cpu and board info
+  char buffer[BUFFER_SIZE]; // line buffer
+  get_twidth(user_info);
+  // os version, cpu and board info
 #ifdef __OPENBSD__
-	FILE* os_release = popen("echo ID=openbsd", "r"); // os-release does not exist in OpenBSD
+  FILE* os_release = popen("echo ID=openbsd", "r"); // os-release does not exist in OpenBSD
 #else
-	FILE* os_release	= fopen("/etc/os-release", "r"); // os name file
+  FILE* os_release  = fopen("/etc/os-release", "r"); // os name file
 #endif
 #ifndef __BSD__
-	FILE* cpuinfo = fopen("/proc/cpuinfo", "r"); // cpu name file for not-freebsd systems
+  FILE* cpuinfo = fopen("/proc/cpuinfo", "r"); // cpu name file for not-freebsd systems
 #else
-	FILE* cpuinfo			= popen("sysctl hw.model", "r"); // cpu name command for freebsd
+  FILE* cpuinfo     = popen("sysctl hw.model", "r"); // cpu name command for freebsd
 #endif
-	// trying to get some kind of information about the name of the computer (hopefully a product full name)
-	if (os_release) { // get normal vars if os_release exists
-		if (flags.os) {
-			LOG_I("getting os name from /etc/os-release");
-			while (fgets(buffer, BUFFER_SIZE, os_release) &&
-						 !(sscanf(buffer, "\nID=\"%s\"", user_info->os_name) ||
-							 sscanf(buffer, "\nID=%s", user_info->os_name)))
-				;
-			// sometimes for some reason sscanf reads the last '\"' too
-			int os_name_len = strlen(user_info->os_name);
-			if (user_info->os_name[os_name_len - 1] == '\"') {
-				user_info->os_name[os_name_len - 1] = '\0';
-			}
-			// trying to detect amogos because in its os-release file ID value is just "debian", will be removed when amogos will have an os-release file with ID=amogos
-			if (strcmp(user_info->os_name, "debian") == 0 ||
-					strcmp(user_info->os_name, "raspbian") == 0) {
-				DIR* amogos_plymouth = opendir("/usr/share/plymouth/themes/amogos");
-				if (amogos_plymouth) {
-					closedir(amogos_plymouth);
-					sprintf(user_info->os_name, "amogos");
-					LOG_V(user_info->os_name);
-				}
-			}
-			LOG_V(user_info->os_name);
-		}
-	} else { // try for android vars, next for Apple var, or unknown system
-					 // android
-		DIR* system_app			 = opendir("/system/app/");
-		DIR* system_priv_app = opendir("/system/priv-app/");
-		DIR* library				 = opendir("/Library/");
-		if (system_app && system_priv_app) {
-			closedir(system_app);
-			closedir(system_priv_app);
-			if (flags.os) sprintf(user_info->os_name, "android");
-			LOG_V(user_info->os_name);
-			if (flags.user) {
-				// username
-				FILE* whoami = popen("whoami", "r");
-				if (fscanf(whoami, "%s", user_info->user) == 3) {
-				}
-				LOG_V(user_info->user);
-				pclose(whoami);
-			}
-		} else if (library) { // Apple
-			closedir(library);
+  // trying to get some kind of information about the name of the computer (hopefully a product full name)
+  if (os_release) { // get normal vars if os_release exists
+    if (flags.os) {
+      LOG_I("getting os name from /etc/os-release");
+      while (fgets(buffer, BUFFER_SIZE, os_release) &&
+             !(sscanf(buffer, "\nID=\"%s\"", user_info->os_name) ||
+               sscanf(buffer, "\nID=%s", user_info->os_name)))
+        ;
+      // sometimes for some reason sscanf reads the last '\"' too
+      int os_name_len = strlen(user_info->os_name);
+      if (user_info->os_name[os_name_len - 1] == '\"') {
+        user_info->os_name[os_name_len - 1] = '\0';
+      }
+      // trying to detect amogos because in its os-release file ID value is just "debian", will be removed when amogos will have an os-release file with ID=amogos
+      if (strcmp(user_info->os_name, "debian") == 0 ||
+          strcmp(user_info->os_name, "raspbian") == 0) {
+        DIR* amogos_plymouth = opendir("/usr/share/plymouth/themes/amogos");
+        if (amogos_plymouth) {
+          closedir(amogos_plymouth);
+          sprintf(user_info->os_name, "amogos");
+          LOG_V(user_info->os_name);
+        }
+      }
+      LOG_V(user_info->os_name);
+    }
+  } else { // try for android vars, next for Apple var, or unknown system
+           // android
+    DIR* system_app      = opendir("/system/app/");
+    DIR* system_priv_app = opendir("/system/priv-app/");
+    DIR* library         = opendir("/Library/");
+    if (system_app && system_priv_app) {
+      closedir(system_app);
+      closedir(system_priv_app);
+      if (flags.os) sprintf(user_info->os_name, "android");
+      LOG_V(user_info->os_name);
+      if (flags.user) {
+        // username
+        FILE* whoami = popen("whoami", "r");
+        if (fscanf(whoami, "%s", user_info->user) == 3) {
+        }
+        LOG_V(user_info->user);
+        pclose(whoami);
+      }
+    } else if (library) { // Apple
+      closedir(library);
 #ifdef __APPLE__
-			if (flags.cpu) {
-				sysctlbyname("machdep.cpu.brand_string", &cpu_buffer, &cpu_buffer_len, NULL,
-										 0); // cpu name
-				sprintf(user_info->cpu_model, "%s", cpu_buffer);
-			}
-			if (flags.os) {
-	#ifndef __IPHONE__
-				sprintf(user_info->os_name, "macos");
-	#else
-				sprintf(user_info->os_name, "ios");
-	#endif
-			}
-#endif
-		} else // if no option before is working, the system is unknown
-			sprintf(user_info->os_name, "unknown");
-	}
+      if (flags.cpu) {
+        sysctlbyname("machdep.cpu.brand_string", &cpu_buffer, &cpu_buffer_len, NULL,
+                     0); // cpu name
+        sprintf(user_info->cpu_model, "%s", cpu_buffer);
+      }
+      if (flags.os) {
+  #ifndef __IPHONE__
+        sprintf(user_info->os_name, "macos");
+  #else
+        sprintf(user_info->os_name, "ios");
+  #endif
+      }
+#endif
+    } else // if no option before is working, the system is unknown
+      sprintf(user_info->os_name, "unknown");
+  }
 #ifndef __BSD__
 #endif
 #ifndef _WIN32
-	// getting username and hostname
-	if (flags.user) {
-		LOG_I("getting username and hostname");
-		gethostname(user_info->host, 256);
-		LOG_V(user_info->host);
-		char* tmp_user = getenv("USER");
-		LOG_V(tmp_user);
-		if (tmp_user == NULL)
-			sprintf(user_info->user, "%s", "");
-		else
-			sprintf(user_info->user, "%s", tmp_user);
-		LOG_V(user_info->user);
-		if (os_release) fclose(os_release);
-	}
-	if (flags.shell) {
-		LOG_I("getting shell");
-		char* tmp_shell = getenv("SHELL"); // shell name
-		LOG_V(tmp_shell);
-		if (!tmp_shell)
-			sprintf(user_info->shell, "%s", "");
-		else
-			sprintf(user_info->shell, "%s", tmp_shell);
-	#ifdef __linux__
-		if (strlen(user_info->shell) > 16) // android shell name was too long
-			memmove(&user_info->shell, &user_info->shell[27], strlen(user_info->shell));
-	#endif
-		LOG_V(user_info->shell);
-	}
-#else	 // if _WIN32
-	// cpu name
-	if (flags.cpu) {
-		cpuinfo = popen("wmic cpu get caption", "r");
-		while (fgets(buffer, BUFFER_SIZE, cpuinfo)) {
-			if (strstr(buffer, "Caption") != 0)
-				continue;
-			else {
-				sprintf(user_info->cpu_model, "%s", buffer);
-				user_info->cpu_model[strlen(user_info->cpu_model) - 2] = '\0';
-				break;
-			}
-		}
-	}
-	// username
-	if (flags.user) {
-		FILE* user_host_fp = popen("wmic computersystem get username", "r");
-		while (fgets(buffer, BUFFER_SIZE, user_host_fp)) {
-			if (strstr(buffer, "UserName") != 0)
-				continue;
-			else {
-				sscanf(buffer, "%[^\\]%s", user_info->host, user_info->user);
-				memmove(user_info->user, user_info->user + 1, sizeof(user_info->user) - 1);
-				break;
-			}
-		}
-	}
-	// powershell version
-	if (flags.shell) {
-		FILE* shell_fp = popen("powershell $PSVersionTable", "r");
-		sprintf(user_info->shell, "PowerShell ");
-		char tmp_shell[64];
-		while (fgets(buffer, BUFFER_SIZE, shell_fp) &&
-					 sscanf(buffer, "PSVersion                      %s", tmp_shell) == 0)
-			;
-		strcat(user_info->shell, tmp_shell);
-	}
+  // getting username and hostname
+  if (flags.user) {
+    LOG_I("getting username and hostname");
+    gethostname(user_info->host, 256);
+    LOG_V(user_info->host);
+    char* tmp_user = getenv("USER");
+    LOG_V(tmp_user);
+    if (tmp_user == NULL)
+      sprintf(user_info->user, "%s", "");
+    else
+      sprintf(user_info->user, "%s", tmp_user);
+    LOG_V(user_info->user);
+    if (os_release) fclose(os_release);
+  }
+  if (flags.shell) {
+    LOG_I("getting shell");
+    char* tmp_shell = getenv("SHELL"); // shell name
+    LOG_V(tmp_shell);
+    if (!tmp_shell)
+      sprintf(user_info->shell, "%s", "");
+    else
+      snprintf(user_info->shell, sizeof user_info->shell, "%s", tmp_shell);
+  #ifdef __linux__
+    if (strlen(user_info->shell) > 16) // android shell name was too long
+      memmove(&user_info->shell, &user_info->shell[27], strlen(user_info->shell));
+  #endif
+    LOG_V(user_info->shell);
+  }
+#else  // if _WIN32
+  // cpu name
+  if (flags.cpu) {
+    cpuinfo = popen("wmic cpu get caption", "r");
+    while (fgets(buffer, BUFFER_SIZE, cpuinfo)) {
+      if (strstr(buffer, "Caption") != 0)
+        continue;
+      else {
+        sprintf(user_info->cpu_model, "%s", buffer);
+        user_info->cpu_model[strlen(user_info->cpu_model) - 2] = '\0';
+        break;
+      }
+    }
+  }
+  // username
+  if (flags.user) {
+    FILE* user_host_fp = popen("wmic computersystem get username", "r");
+    while (fgets(buffer, BUFFER_SIZE, user_host_fp)) {
+      if (strstr(buffer, "UserName") != 0)
+        continue;
+      else {
+        sscanf(buffer, "%[^\\]%s", user_info->host, user_info->user);
+        memmove(user_info->user, user_info->user + 1, sizeof(user_info->user) - 1);
+        break;
+      }
+    }
+  }
+  // powershell version
+  if (flags.shell) {
+    FILE* shell_fp = popen("powershell $PSVersionTable", "r");
+    sprintf(user_info->shell, "PowerShell ");
+    char tmp_shell[64];
+    while (fgets(buffer, BUFFER_SIZE, shell_fp) &&
+           sscanf(buffer, "PSVersion                      %s", tmp_shell) == 0)
+      ;
+    strcat(user_info->shell, tmp_shell);
+  }
 #endif // _WIN32
 
 #ifdef _WIN32
-	if (flags.os) sprintf(user_info->os_name, "windows");
+  if (flags.os) sprintf(user_info->os_name, "windows");
 #endif
-	get_sys(user_info);
-	// are threads overpowered? nah
-	void* (*fnptrs[])(void*) = {get_cpu, get_ram, get_gpu, get_res, get_pkg, get_model, get_ker, get_upt};
-	struct thread_varg args =
-			(struct thread_varg){buffer,
-													 user_info,
-													 cpuinfo,
-													 {flags.cpu, flags.ram, flags.gpu, flags.resolution, flags.pkgs, flags.model, flags.kernel, flags.uptime}};
+  get_sys(user_info);
+  // are threads overpowered? nah
+  void* (*fnptrs[])(void*) = {get_cpu, get_ram, get_gpu, get_res, get_pkg, get_model, get_ker, get_upt};
+  struct thread_varg args =
+      (struct thread_varg){buffer,
+                           user_info,
+                           cpuinfo,
+                           {flags.cpu, flags.ram, flags.gpu, flags.resolution, flags.pkgs, flags.model, flags.kernel, flags.uptime}};
 #define THREAD_COUNT 8
 #ifndef _WIN32
-	pthread_t tids[THREAD_COUNT] = {0};
+  pthread_t tids[THREAD_COUNT] = {0};
 #endif
-	for (int i = 0; i < THREAD_COUNT; i++) {
-		LOG_I("STARTING thread %d", i);
+  for (int i = 0; i < THREAD_COUNT; i++) {
+    LOG_I("STARTING thread %d", i);
 #ifdef _WIN32
-		fnptrs[i](&args);
+    fnptrs[i](&args);
 #else
-		pthread_create(&tids[i], NULL, fnptrs[i], &args);
+    pthread_create(&tids[i], NULL, fnptrs[i], &args);
 #endif
-	}
+  }
 #ifndef _WIN32
-	for (int i = 0; i < THREAD_COUNT; i++) {
-		if (tids[i] != 0) pthread_join(tids[i], NULL);
-		LOG_I("JOINING thread %d", i);
-	}
+  for (int i = 0; i < THREAD_COUNT; i++) {
+    if (tids[i] != 0) pthread_join(tids[i], NULL);
+    LOG_I("JOINING thread %d", i);
+  }
 #endif
-	fclose(cpuinfo);
+  fclose(cpuinfo);
 }
diff --color -Naru uwufetch-2.1/fetch.h uwufetch-2.2/fetch.h
--- uwufetch-2.1/fetch.h	2023-02-13 15:38:44.000000000 +0300
+++ uwufetch-2.2/fetch.h	2025-09-13 20:12:35.176056523 +0300
@@ -19,131 +19,131 @@
 
 #ifdef __DEBUG__
 bool* get_verbose_handle();
-	#ifdef LIBFETCH_INTERNAL
-		#define VERBOSE_ENABLED verbose_enabled
-	#else
-		#define VERBOSE_ENABLED *verbose_enabled
-	#endif
-	#define LOG_I(format, ...) LOG(0, format, ##__VA_ARGS__)
-	#define LOG_W(format, ...) LOG(1, format, ##__VA_ARGS__)
-	#define LOG_E(format, ...) LOG(2, format, ##__VA_ARGS__)
-	#define LOG_V(var)                       \
-		if (VERBOSE_ENABLED) {                 \
-			char format[1024] = "";              \
-			sprintf(format, "%s = %s", #var,     \
-							_Generic((var), int          \
-											 : "%d", float       \
-											 : "%f", char*       \
-											 : "\"%s\"", default \
-											 : "%p"));           \
-			LOG(3, format, var)                  \
-		}
-	#define LOG(type, format, ...)                      \
-		if (VERBOSE_ENABLED) {                            \
-			char buf[2048] = "";                            \
-			if (sizeof(#__VA_ARGS__) == sizeof(""))         \
-				sprintf(buf, "%s", format);                   \
-			else                                            \
-				sprintf(buf, format, ##__VA_ARGS__);          \
-			fprintf(stderr, "[%s]: %s in %s:%d: %s\n",      \
-							type == 0		? "\033[32mINFO\033[0m"     \
-							: type == 1 ? "\033[33mWARNING\033[0m"  \
-							: type == 2 ? "\033[31mERROR\033[0m"    \
-							: type == 3 ? "\033[37mVARIABLE\033[0m" \
-													: "",                       \
-							__func__, __FILE__, __LINE__, buf);     \
-		}
+  #ifdef LIBFETCH_INTERNAL
+    #define VERBOSE_ENABLED verbose_enabled
+  #else
+    #define VERBOSE_ENABLED *verbose_enabled
+  #endif
+  #define LOG_I(format, ...) LOG(0, format, ##__VA_ARGS__)
+  #define LOG_W(format, ...) LOG(1, format, ##__VA_ARGS__)
+  #define LOG_E(format, ...) LOG(2, format, ##__VA_ARGS__)
+  #define LOG_V(var)                       \
+    if (VERBOSE_ENABLED) {                 \
+      char format[1024] = "";              \
+      sprintf(format, "%s = %s", #var,     \
+              _Generic((var), int          \
+                       : "%d", float       \
+                       : "%f", char*       \
+                       : "\"%s\"", default \
+                       : "%p"));           \
+      LOG(3, format, var)                  \
+    }
+  #define LOG(type, format, ...)                      \
+    if (VERBOSE_ENABLED) {                            \
+      char buf[2048] = "";                            \
+      if (sizeof(#__VA_ARGS__) == sizeof(""))         \
+        sprintf(buf, "%s", format);                   \
+      else                                            \
+        sprintf(buf, format, ##__VA_ARGS__);          \
+      fprintf(stderr, "[%s]: %s in %s:%d: %s\n",      \
+              type == 0   ? "\033[32mINFO\033[0m"     \
+              : type == 1 ? "\033[33mWARNING\033[0m"  \
+              : type == 2 ? "\033[31mERROR\033[0m"    \
+              : type == 3 ? "\033[37mVARIABLE\033[0m" \
+                          : "",                       \
+              __func__, __FILE__, __LINE__, buf);     \
+    }
 #else
-	#define LOG_I(format, ...)
-	#define LOG_E(format, ...)
-	#define LOG_V(var)
-	#define LOG(type, format, ...)
+  #define LOG_I(format, ...)
+  #define LOG_E(format, ...)
+  #define LOG_V(var)
+  #define LOG(type, format, ...)
 #endif
 
 #ifndef LIBFETCH_INTERNAL
-	#ifdef __APPLE__
-		#include <TargetConditionals.h> // for checking iOS
-	#endif
-	#include <dirent.h>
-	#include <stdio.h>
-	#include <stdlib.h>
-	#include <string.h>
-	#include <unistd.h>
-	#if defined(__APPLE__) || defined(__BSD__)
-		#include <sys/sysctl.h>
-		#if defined(__OPENBSD__)
-			#include <sys/time.h>
-		#else
-			#include <time.h>
-		#endif // defined(__OPENBSD__)
-	#else		 // defined(__APPLE__) || defined(__BSD__)
-		#ifdef __BSD__
-		#else // defined(__BSD__) || defined(_WIN32)
-			#ifndef _WIN32
-				#ifndef __OPENBSD__
-					#include <sys/sysinfo.h>
-				#else	 // __OPENBSD__
-				#endif // __OPENBSD__
-			#else		 // _WIN32
-				#include <sysinfoapi.h>
-			#endif // _WIN32
-		#endif	 // defined(__BSD__) || defined(_WIN32)
-	#endif		 // defined(__APPLE__) || defined(__BSD__)
-	#ifndef _WIN32
-		#include <sys/ioctl.h>
-		#include <sys/utsname.h>
-		#include <pthread.h> // linux only right now
-	#else									 // _WIN32
-		#include <windows.h>
-	#endif // _WIN32
+  #ifdef __APPLE__
+    #include <TargetConditionals.h> // for checking iOS
+  #endif
+  #include <dirent.h>
+  #include <stdio.h>
+  #include <stdlib.h>
+  #include <string.h>
+  #include <unistd.h>
+  #if defined(__APPLE__) || defined(__BSD__)
+    #include <sys/sysctl.h>
+    #if defined(__OPENBSD__)
+      #include <sys/time.h>
+    #else
+      #include <time.h>
+    #endif // defined(__OPENBSD__)
+  #else    // defined(__APPLE__) || defined(__BSD__)
+    #ifdef __BSD__
+    #else // defined(__BSD__) || defined(_WIN32)
+      #ifndef _WIN32
+        #ifndef __OPENBSD__
+          #include <sys/sysinfo.h>
+        #else  // __OPENBSD__
+        #endif // __OPENBSD__
+      #else    // _WIN32
+        #include <sysinfoapi.h>
+      #endif // _WIN32
+    #endif   // defined(__BSD__) || defined(_WIN32)
+  #endif     // defined(__APPLE__) || defined(__BSD__)
+  #ifndef _WIN32
+    #include <pthread.h> // linux only right now
+    #include <sys/ioctl.h>
+    #include <sys/utsname.h>
+  #else // _WIN32
+    #include <windows.h>
+  #endif // _WIN32
 #endif
 
 // info that will be printed with the logo
 struct info {
-	char user[128],	 // username
-			host[256],	 // hostname (computer name)
-			shell[64],	 // shell name
-			model[256],	 // model name
-			kernel[256], // kernel name (linux 5.x-whatever)
-			os_name[64], // os name (arch linux, windows, mac os)
-			cpu_model[256], gpu_model[64][256],
-			pkgman_name[64], // package managers string
-			image_name[128];
-	int target_width, // for the truncate_str function
-			screen_width, screen_height, ram_total, ram_used,
-			pkgs; // full package count
-	long uptime;
+  char user[128],  // username
+      host[256],   // hostname (computer name)
+      shell[64],   // shell name
+      model[256],  // model name
+      kernel[256], // kernel name (linux 5.x-whatever)
+      os_name[64], // os name (arch linux, windows, mac os)
+      cpu_model[256], gpu_model[256][256],
+      pkgman_name[64], // package managers string
+      image_name[128];
+  int target_width, // for the truncate_str function
+      screen_width, screen_height, ram_total, ram_used,
+      pkgs; // full package count
+  long uptime;
 
 #ifndef _WIN32
-	struct utsname sys_var;
+  struct utsname sys_var;
 #endif // _WIN32
 #ifndef __APPLE__
-	#ifdef __linux__
-	struct sysinfo sys;
-	#else // __linux__
-		#ifdef _WIN32
-	struct _SYSTEM_INFO sys;
-		#endif // _WIN32
-	#endif	 // __linux__
-#endif		 // __APPLE__
+  #ifdef __linux__
+  struct sysinfo sys;
+  #else // __linux__
+    #ifdef _WIN32
+  struct _SYSTEM_INFO sys;
+    #endif // _WIN32
+  #endif   // __linux__
+#endif     // __APPLE__
 #ifndef _WIN32
-	struct winsize win;
-#else	 // _WIN32
-	int ws_col, ws_rows;
+  struct winsize win;
+#else  // _WIN32
+  int ws_col, ws_rows;
 #endif // _WIN32
 };
 
 // Args struct for get_something thread oriented functions
 struct thread_varg {
-	char* buffer;
-	struct info* user_info;
-	FILE* cpuinfo;
-	bool thread_flags[8];
+  char* buffer;
+  struct info* user_info;
+  FILE* cpuinfo;
+  bool thread_flags[8];
 };
 
 // decide what info should be retrieved
 struct flags {
-	bool user, shell, model, kernel, os, cpu, gpu, resolution, ram, pkgs, uptime;
+  bool user, shell, model, kernel, os, cpu, gpu, resolution, ram, pkgs, uptime;
 };
 
 void get_sys(struct info*);
diff --color -Naru uwufetch-2.1/res/ascii/menhera.txt uwufetch-2.2/res/ascii/menhera.txt
--- uwufetch-2.1/res/ascii/menhera.txt	1970-01-01 03:00:00.000000000 +0300
+++ uwufetch-2.2/res/ascii/menhera.txt	2025-09-13 19:35:43.225771278 +0300
@@ -0,0 +1,8 @@
+{MAGENTA}        /\
+       /  \
+      /\   \
+     / >  <\
+    /   __   \
+   / __|  |__-\
+  /_-''    ''-_\
+
diff --color -Naru uwufetch-2.1/res/COPYRIGHT.md uwufetch-2.2/res/COPYRIGHT.md
--- uwufetch-2.1/res/COPYRIGHT.md	2023-02-13 15:38:44.000000000 +0300
+++ uwufetch-2.2/res/COPYRIGHT.md	2025-09-13 19:33:48.587890269 +0300
@@ -111,6 +111,8 @@
 -   Copyright Holder: [Houl](https://github.com/ItsHoul)
 -   [Reference](https://github.com/ItsHoul/blobicons/blob/main/PNG/devuan.png)
 
+#
+
 ## Endeavour OS
 
 <img title="Endowo Os" src="https://raw.githubusercontent.com/TheDarkBug/uwufetch/main/res/endeavouros.png" alt="image" width="100">
@@ -186,6 +188,8 @@
 -   License: [CC BY-SA 2.0](https://creativecommons.org/licenses/by-sa/2.0/)
 -   [Reference](https://www.reddit.com/r/linuxmasterrace/comments/lyi8ce/its_actually_gnuwulinux/)
 
+#
+
 ## Manjaro
 
 <img title="Myanjawo" src="https://raw.githubusercontent.com/TheDarkBug/uwufetch/main/res/manjaro.png" alt="image" width="100">
diff --color -Naru uwufetch-2.1/res/menhera.png uwufetch-2.2/res/menhera.png
--- uwufetch-2.1/res/menhera.png	1970-01-01 03:00:00.000000000 +0300
+++ uwufetch-2.2/res/menhera.png	2025-09-13 19:33:48.587982264 +0300
@@ -0,0 +1,263 @@
+PNG
+
+   IHDR       cI  oiCCPicc  (u;KA?5-D,b 
+b)L1fwI$.$
+6W?VUEjD;dqferf|s6E	SO#4kON&9>nSfPhIY	uMxSkxK)G(|t#';TO-?lfpp4+Q7i
+sRe N"+Z~|3M	G(]-i-rTt#A4<k/Du8/T8hmB;J~9<Ao_gf    cHRM  z&         u0  `  :  pQ<   bKGD      	pHYs    ~   tIME	129o  zTXtRaw profile type icc  8S[n!=R<$j?ZK+<c3I)%ArFJ^lR vcIw!VaGNtPHte(3Meh;f/-8A;_fJ-/B}D%"<k[7qh/0
+nWqBz/"-bq5ZsPjUe]xY_(aQ;JD^(<z{?<{41#- UI)r2sj{b2\'4=lOUc^^q_>[PS   orNTw   IDATxwpg3u:US;;3988 L0`01"g( Z9s\BS;tq        mG     (h[(    PY/F
+y     ,_it2M<     J|b    XA):iXG     IhJr3M     PaeY
+y     `Z4N2)    Pil(`     1n4Nf)    PQ0S    m6):
+y     hM4N1     hs?M54    +?*4:)b     'vCQt     xLE4Nf3     wJtb     O	-69U1     wI     puN4:1w     ]`%4N     K~gxv    p%&Sn,     n"~(gz    T]^OdNB     W6B~F'-    etn+itw     \[ZG     '?ME&v    pVt#v    pLG
+ NE    R[<ReIB     G}ch!?M6F    `uLBF    `ji)    +4Nv)    URstX3    6^'7    1z!*Qt     i[EP;)    Tb
+    `Dm}"~F'SE    S%B1    JWO$0EG!    vYO$Qt     \na^<M     DRsbihtR    `q]OBv    W3s#eN^:,    fC9]<    USIS    :j$0    1P@;    j2Y%(EB>0E'f<     KQuE<     lT3	    gzU]O$Qt     ?2B~A:     ~_EPR[E    q>SRH;    B~VG!    ]g{}R<    7}b]    Ol"~(iz    1[KL>[6P    |KPgitS    |JO4:(:    B~vB    ~%EPU)    s/i(    Ug"~(I    *khz    PY+itR=@1    P~,it>]y    ,4m!(:    $0E4NY(    Uc"~F'F    TbNi$2    tM#M     JC"+<    @fh)/    jgJK*?     	p6z    (KrsE    (<$F    g@8V?z~    @)BMc$(EG;    2,HS3    >+bFS    vFF    $,`    [v)Qt     /zG>w     P;Z<    eL(    Qqgj>O    BL.F    hwQe(    YM;W&Qt     7Zm wa1    &].Lw     Xn;<    VvGSE    pc4sgbE    pYz
+n7fE6     .KdS    SB]y    Z3IJ1    pREV(:    (=~     QX{!k-     7*w     ;PT{1]    as1MeY     ]OAZ?@1    [b3M    `>LB    0~h%Qt    Q("w    Qr^I	Qt    aWY(+    *3
+My{G%IF[<    EIP0+5aE/R<    F
+f'0E"{IAh    5P, UE(A):YIw|    P4SEft`geY    29Qt^/S})   @}~+(|AD!    j9e]i1Y7't{)   @9ewMVYgsw}e_NKnB    @X>Xi Nkum\4    ud7^	zW~YMW7l~<    (^
+bga{VK
+wo~<    (\#GenoEN/779izs?    d,n+htr"U4:.    xNr;dW}?Rmq    (H*4l-1IvGel6o/nR.?    P4hcWY$qsCY9    P+`?,W]z    P4MKvn~cikRRMz    P4#W64kr    t3S?T'4R   .3SQFL0C/     jXsn*    @9G3/M/u   d    (ZaWMe~^V7nusn@:%OD'9x     vn\`Yz	Jbx?gj2'M/Q5    9k1oD    pBKlL^BL    o8%_^v   [(ReYZ{y    M`Ly    P&s9izYgF   l`7\N~7JDE{}    Eb4=;    (YbS/,,F    5?xrye(   @R[9GR_x    P&
+W2lV+    3]KJF     [K'goB    bvXe    (BbsPr]y    eYTbS+    ^9b{4:l    oHJ,F   )NbW    <oW8ME&
+y    4
+R(:    P^
+R<    lF2]V^^M    f9%meW    m]#k2'    vR9G\Fv   m*9G\5F
+y    p
+OhthR   60r'(   aq_*u    *9@If
+y    p5#TF   K42CKIC   W0rx&3iz    NiX9Qtm}    c
+L<    8ny6#O1    $^IHB    Mx|J1    HMK!    `e#ozf^    0VF%$<    %sDe    ii&#rrb    F'DAYm   IcQ^)   J]DY]y    Jh(2):)   !F+wZl   ![K'NF'5zv   `qOQ~v)   LC/E"QE    @$j<    GqHTW.    >HqHT>y    {sDYe   ~*`77v   v7R9G5F
+y    Pb:A):7X)   
+A<    ?p"L*t    |l 0S   ]m}2S   e^v+   HMf~:    |Phl5Q   5	#>Y   !{{K1   7O3R   P<	$b   MRl<    Jo#~T(   (   OV{?E+   @u~*0R23<    hXes37MO!   @=6(']y    *`J E!vyW    h58B.Lc/    m^w	t   PreN+  JrWRZXg-4PrEVx  P=awRmAc#z(lROF)  @-j,2"/0E'krr"En,VYEzmgL5Hb3'	0%2bepW  @HquyF)v}AwZl(4JzpHES~===O xBJ^g?   J'/4:&C/'zdje34_>t8F)a&
+5B"   J'3eYIhr>^.lU
+e4N4N}aE$0E'U:?  dr\oxN^ZEKnGEW'z*]"v	5
+x  P^]Vo#_ebg`):6JSbcf  @v]}D5flnFb?LLF8Q ]/{3Br3   j,4:Yi#v7n,H9*)O,l)qe"!4  (]Z[xrF',#4sNKAqv	q8\O  PaM
+u-eUa]y)
+2Bt  OFZbj;)-8^lNQZ[!N&]y   uLd\hR^e7Siwg3]y   9i+SH~@~)49uJ`Q^ZL}<WDhtG1  5C):Yi=fq~`N{Y
+a(s  PyF
+}aN(xB|=M|
+  m5-1"!.<#   jSuyp{E$efV?z%}D//  @-j#mB|aSuLNn~r3M|v	qWfx  PdG)=|dZ lk6<s{LBtyAUYdgYL}Q1l5<*3KtE4Ohep&+!n2SM   Her}5Ei\): ]/+CQv$"}R3pq=xb7'   R/-Eb U-[.+o
+-5.%Sug4yizYcDB)  W9>[r68b~|pw("eBLLJTUai?+U/K3$IAWtHa@ZL4Qv	XB  P_^+?\o7_nIPNflc/;\NZe"Ce'  7:+?Mb+7l*GW*^L^eeSINJ9GHq<* un%vCmK||R< {(fr7o4`4Fdv$^BS/ w9 |%Byr"y.^>>!S{bL^12hZX\GAErF`$UYkl -p|')b~|`vG9Jzn(0RPN<0rW]KFk/Z  8Tivj\DErRy.^><._%bzV'r_G{OL!\aOy^BW9~g@*$ 3:Y ~i}N54%E
+]e\D|'2]rv,'Y<p~wKF'+OVf$(Ew,4 LI	]2>8[!kn='M/^eo-E;BFxCBL^-*n\` LOI64];Jzg{RJMQ($q#v5X_2#j[3 8 b%)/omn-2JuYf"]y#r:ea^kuCQZ]r+l]S4:2 =m-VjwnFHQ}sizGX-l,u7<A5
+ ;e?za`'kSde*zH;B&vj ]js[GjZ.+u@ 8aYiUD!e7wkS~w>(E'$S33	jdRTwI0;+rb*0tp g)OMs+woR$wO~v?(epxdO7{owSX'%_JLm=s;
+ )]6OuwXR><w1PT,bW)u;f  Xxt"UWbyh_Jbwl<BKF]{466DZx \]Bwn/g#dRN2Z
+*BFFU%O6*cBJHs .Tk9i4'
++Hz9\o''v*U4lMY:WY$$eQ^fWN* ac"|@{EHvr:V; BdqH^gk,KM$dCQ6oF	)20Kx`YcZ$6IRs5^LlC4DT[dY`Y]WegYv\3dSIveoYT[PY"-Ucuurr1*^< suPkjQ^|A p^~DOWys<R9A)GVE,8VJ1O(:~W/M^eX3|e9iz6<\+oz MZL}~~&Nk25S2YA1O'lJ~g&Ymx(=Rb^^RZh 	 p"y[BPbdJrO4+bR/'KtKtE\?d~^) xwWnT U>C< =_W8fO]y{U$WdEAkezF9 <b#VL!]S56:IEInGK'S#*d[~gl/5,]A*8 ?~\R ,5tNUx}Ag5x"DaMV9+?eNw35Y'_$v29K>O]2)s?sm/ f?^KnCs?qmPqnRXxSQW-7L*[&wVyh<sN	V=;K%rbmKHn\(l.BmKi[yw<yF<,;>  /4{tFb.-L[6(-&YMo'9Rm%WVdS)=2)S^=(U=;K-Er68_9=f/oR$].msj ? Gby.^d$qY`b>j,H+9"U[=.dpK9_]Id" j-vGm)@w=;K]7SZ.d;'QBw_
+cZ+MNs*6  y0mhX*htCQ7zU"-0u,S:,GcaUmr]rOL>sz9K PY>yuKYcfQwGvwv dMQky^/mN6ypTn
+-v$7I @<B	RZ.9fO;kuXUUes0]
+w!2>XeW)_~x ITyBuhZyBz)~]77}UrU.) j{vR7J;K(	>Yc@\vrREww6w(uiV Td]}cM}kuYueY(BGZd}^|=Sual<BTd'6 
+y zW7}n]5[@.4Haw$vYJ3RGaTxo>/ouD P~:>VE{+T*egHiQQ~	.2oovwKF5y  k7[?TCUOW/#go~>t/FFNXX\K+'htRn< @~?Rd{0m)bTKX\`k9mp;FnfFmKOuw$7o.IN4JIn *Va<#)PyxfQzUe3OSQ?z'%_%u~Z%x zert#/M7?]Cf_IGkB\zOmcny4Js| M  jhu#V$jgv[k3Ok_]60 E&X?/[9\(#  [cVh'OI)ghurKw[L+';;,RLNd9izi[= @vm0T6k~{,yB\6^i7[cJK^^r  Kn3J)qVhA:7M/^-<!n)ePYHdEg8FoG>{w}gRt'K5]  j4Zm g#0+]/%^[<m(0R #,E]_%5F;O]Kogq=RR [>>9?-d^937'?ol7FUp5 Y!v
+y MUUo/BMEy.^neF-u  *'wu!UZnsbFC*ENyho3VV}  *?Ob@ypo|t.3{[n!k{Z%4@ NV ~rwO9<S[
+.NRPB<)=Rt0;Tx4 wur'tnPw.$n-p2]&WLheg;2SKC;g29K?PU5fm&x i66]e,$\TtTQ*7n=;KerJK~yBhQdsE^BX'O 9|>VbC*#ur2)#u[IKvwY]27db|<~ZnDgrf\9 ;PbV,ohcjN}9v-t%|a@fPB\w(_P?>
+y  <	yH|#'tKrP>9b>f(B!Ny,]xMbi1YW =cJnhX{_'+G-Evtz.cz|#!|#/F5m[+I	mX= {iv*O:._:uK\]kte4&HwnB'_)5o-vX}Z+ >.o{wPDynL<skU.`,LB5oif<@#x +a;(=[831w~nT]%u
+(j,2]KB:_%C*wIyRu7>x h5[>z{J6OBGwER2SvxqbrQO{+p4x .gn7ry6N$_}}jN&;KGR}g{(
+B9cM=r]V<%4R `Q\/O"[
+rmp<Q"WdI&.yd*lUR{XGgz) lc]g<qZ<=syBMYzU1chE=%@3iY!Y\ .:q]nT`suL! /E]~)=B>Or|wn/UC16(e=^]m(`<!2-E{!
+LQ QtU;GbH;Hw('G;(E'Gk-^])g<!kMr]H\/OG].$_n-[{2r ~)4:+	w(gr7X~-BQwsbcMrt kwNZydDn
+-XCMrShXY*kyX}Y8X-7R_ZI u)=m,0;mc.Dkck*ZldkIZLx4z}vb||.jN{Z[mY|LNK:ytSaKQv=sir gU:rA79u]%^2d wl+kp>s3:IYN1O~R<{Nn`jn2 qE77aUr"ggLsyB<Q/wl+v>8dqAoy6!kO|><5~
+y Wax'g;'@8mb{wy,vc\]29gA):[nv7~m)1QBrt#cZwT
+ 0n\v{aEb7O4_UL*U.9oBHF' igy!?G=D^e `qeGk
+t9qFI'trbq=R6Hk=!D>>!wm/MJ7@! q(5X<syrS{dBLTx9WggYV-
+:e>M|-8\SW4>?) 7bZ'@>\k=tBvm?Zf_Y\|&oo\tmjZh[ ef'BrM#YXohGOg=r>$IeLgzu.M  2auR m}l*Y`F)f1'2)S8Xi${w=$B +vXp}v6"qrb<sNna<z~}gZ*G| UVfsrb vw]NyHi[;?,44}X3 37O29K&w	]29K:xWMrB>bn|<  Hegq@&'v|RTto-!53zIhrBq]/eBL<Q/;m[rBeKDR^jOv\OIOM:yt `TuGg})}G<-k1O\JfqzIosoC}foBR>Uwl+gg,&cMMTNqV't `lGTxg!2f[I=&b6xku!f.Fnw1Wfj7O7|ypOwE$<xMv	.2Q `~:<w?=h>O<ruK(F[=#!/_{rRydL*>ip:B +iZ?sx_j`W~vvuMnL<Q/<bFitSAC>	t$ZTO:.+jti\B;f[)  kYAbn?;04M&wGA,+cL7;[C5al|y[&~NqK	}v
+  $sR3pQkOio-B!p^%qwjV M8XM1O[aW Ny`,(  $ ):Yc{`_1oooYIeYyBTY_Yq"ydR[ `4sn-2Ao\(RwN(I^i3[+Oby^;4qs  nN^4:	PJ*Q\BQe72lYcq%G
+z_n7R 0,4;:Vk>p_9B
+MGuU&0C>_qyu;D;  F'A)EpMw
+<l`rYSn3U1B!<vJ&c7 16J1F9;9ot uK_2lfeOMpoym;htrB! X"k,:r??]/3##w(E}.%+,|]V	M	!Jl~
+y  <nh4N>_|1a7l*],z;Oafi5[_u[k%'*<}s-&LVg  awmy*!/D_uW5.$_S.S{XT`Fc;'3y.@>1^x  l/]\O0X_w"y(	JtT=G	qw&wM62SJ1  Hy['Gu2j.Mm2)c5YcJ]j,H'y,"I/n#c  1)=rgveooojQAlx,ruQji( Uv{Lk_v^N4w%7r]H<V%bZYmvmy]Tv	qu&N|Zv  dN{O2o]FkZ<|D=Mv*lE_piB]PvGK.jK  }B!7o.vyr"yT{89izRb_{d%EyX9 `rEm"U5[1NVyB;2?%sE0]	qm>:.7okG|y  x<;_$v}T es|e.y%QsD9	0(-7]'VWu;wgx  \bZ'/F5ve ,Qlf@YjWXyB\O:V]swJfx  OUiXG|n>$?+s']yN
+l7T(  8h/u=;K.$_=dRt4 qWo2YeI'2QM]{$"  g#{v~<y`LMfAJ|?2r"_wUY$8fW~BL]\ ::Z?Q;drbQwYoXty@L].  peY9bnyh_2o)cYM`N2HtELVP`q!]y{htw  b=^?RrtPB.dv|#]	q`W;?iUAe m=|rCn}B9RO!eySTds  yP?&{ehX!tysLX}`N,  _W6z|Bw	!|N8X7*lB{ >,=^?M)=.|
+e7Bal1u!z)H=  nS3yY|H8B[~x_wl+zljSK }cmrw1_%<!7S-r]HO7{6Qs;JM  xZKn/FBqkNwl!"hCU9x  <hZIGoR$_pBq&kT%/Ka (o{1nw-!L;\!5>x  <-k<-rm,.	!x,O>T_`N3z9QwJdIbS4BQ r3+Bd${%!3rc{@LIzZPNv%_pE~)4LNL^e}Q;9v [$5ymWnoWK BE7J4(C/Gk-  F-?&7o.t6BB>Qt;';patT( zUf z9Qwlv$f].OM2xg~V'J' G4{Xu_~B.cAI!;XNvw;u-0e}i7  xT*^xdS#$!djNY"myBS N6 Wx<?.wpoIB!^['UUP>p=;U/e= -8iL8V?$!a:F@iu23E<  PyF	.2I(i4NHGk<!o*hzwyhK2`R 3^x3^)PTfwB?f:R .92]{Q
+'W|nZCS{Sr2}kQ	!h>>;<fw  xl#cfeEA*/#v~T<^3j1mB~BEO92r< & vKMc~>CeY	)24GS{qb.e B
+Cw]H<}Yfa^J gW>^.n}Hoo;+*7$<V"yEw]G $4J`o,>9!UM"BB:El.53z$_;F=  .Q3 R>P#KQ*wg|"BW&61OQ*nsiV^N]h^VjZdV/R< ?) p7bI!*{m*eRBKc)>(^d^^) pVtgB!J	]\mpX^=(_ven^d}QfmZChjK k42?]BBqcnR*W6..4y-%&70  RxB!Y\\R'g;dfkSt(c/ z7#Bz
+-nhl/%$qlb  S<!<Qn]#:9RmV LVYi`E!8?T%vr'{} [d#B+
+yrRV}Ndw  4#B\{v[~y4J>>Fv&0E'!E&x  b}bBqQUfrBy`OrQHV"  ,B!8Z"{G<B=R'kN42!U>>!_%u+%  (RAW,H<!l>"n)[S529K&} @4-}2By9A>PwG. @d<!	$  JJK,'B1 @;,	!?L^"-  Ya@~7J`
+B!7J~"  _q,R9jO!.|d  >Y<!+~x  |^Ye	!fA^r:( %7b,4-E=!,4H.E<  ~^/1(,!%|#<  BBQXfP"  \&B!DAYe*  0RZ'B  Yn<!$D  FxZp@&*NBqiku^e  [gd4J,&0W~	s<V2B&k4cygL\zIm  KkMrW#efr!nK;}wowG~8htRQz  `uvKS3 >ZbY	JEK	,	!~~9-'Fc5'MQz  `;{A):!(E].6ZdE'v?=^#<vSu,	!~7'MV8~}Q
+G\  p&C/cTd[Ifqw6Ma?]0f0  EL^*`HoWM.Y^[\-odOL<Y',7vc" 5x  0UTm:7]-%&7XZhl-19H\ 
+I<~y}1X9  `~.gXNL}Nb*Ci
+ypE !Dy1$Fvy>1HNw &hS%&)q1~bn_Uro&O>zm  c+,82eQEZkLWx'FylWSG+(!GzL;R5;U/Q5  vpp'>(e`%&I`~0{3O|wULQ~89gr{Sts3  %2H^Qn7g~:wr)!#{o_"7NTO!?SF   n'A
+dL.Zy`v@AZ^?_?iV'Kr"-&7|  \dRljR@/^ *c<"wf$"U:f  ?R3]nW"? 5Q{Pga^%W}  ~la2}]K	c?_PWy1	dN^U:  @ue(wSk/^;OAq:c!|+S))S  \h9izE/rZKGyB'+=%{<2&n~YA   WZ/v_yH?L+/oN(!w5]mf~^)  0wC7.Knlb(b)P!6S{o_"[&0E'-  Jw=]kuG)T!#*.$@  0&U.-}F'.wh)Z!F-l|zQF'   YcP_N'SlAgO^"x;=-wQT{V'9   Qy{2tbw.uB!~Wk_oJS7zx  TdVg/?7G-/!
+3']|y)4AB#<  h2T1z|zZ
+Y}3bq<$S{Lc/<  hNc=]rGQ7;?_T{S%gF?@!  0ef-itjSzExo<}<p"_YBY<s;  0~~![3]8i'VylYoS
+  iiob%J(|&U{9]Ug  MV[{*UB;E!
+k5r+}cLWc;]Vf>  F/3 rG];_NS@w0_Q	U$Z   cIi_!LEwLA>8RLAEytYbnr;'  -%st?<L3	L9%O~)xob_ytrG  `T[KL,y[]q<y!qu#
+Wg~:s}`N{)  F0C}S+T{g'xqxbO+S7s   (gnCtynC!N-.o|#<  HVX	?({w~v|qw#SEW,<  p%nvO'oN"d<]<7RhR  \iq&tW1
+"dHnN5S[{29
+JIv  .s+
+#r` w$"BY_55,$@<  nK64i"?L+/my"=bG8qjW)I]~(  $4J {k"?_~-!
+F_TS3s_4%ix  p43?"S<Ojm)drNKz3  q7syuk"_N'x'v  <[3W@jy}Zy?yH1I;  "-,8ov*xxn#j:BbHY=y  L8T wmP\qqM<?"W90  OUY*((xn4U]W>;Qs`d+  PbPG*xgQMn\<W.  %sU&
+QDqWM{.7v<0K  dZjKOxx(>	U\wg3?1J]o  aSU^-FMk_Dm<7nJ:  1SKz5ruiz Qt$u)oO.On  mC#/NX(:_zqryu[22]  EJ>q'o_c'x|w 
+n?'O1EOzuWdRL= ]O!  |OQWS}>>Z!-,yBCv)Ky>#y  [gX8_zss@TwrVf!  vKP
+<5ffybV`!QMY15,Cx^<v Xn2T<E#sBT#?^bL?*Ox(-&7|  U;N)BZw*l9BL~k99]y  vrWK^L8a
+x~R^';,.? OW'j1yu[@ZY7gv*w 5SAa\}e{jm<p7'Tf2P/&-_|7x'Kk"6z?=Q#wL]m_/Dl.6Q  ugAIrg*
+WwYmrF}LnL^>?z+nw<|Wxu^[{#?GYzi7[J   J|c/s6c:pZa|crGu~{H"w*Ol+eW  t-8%Me[q88Fub2=|vwoIO8=  @WYX)s7+1kwj-ea~z/r\?7NJ;[K  *FqQq>\$7MZ{`>z[[\-kZ)#OYwzb  (237.[\|xwo1-n;<lG~^MMr_||AK]eY
+y  \FhSB\%/my<[c?UHnJe  JVnBy*_~@&im=wO&w	f{;PCc<y/g}B  (Oxo_8q0T~l=?X'j<2n.<s\~;D( l*6PR&j..oI.f7|+Sue\uEtd]  @A3g[*oN|QW#opgN]_QuT{)  *#.oNw+[xn{8q
+F^:yty2
+#s  
+:YyS)ebH>G}=hswhUkWa<G6$@V  /P`dq<.{8=nKvc^xeprh,d<  ~	`QH]k?F>R&us1? +s"?JpIes?^y7,Wn|`s4FNR  Xx:#R<$!}*2bxxe9=&|pYzp)<G#d)  
+wwGfoRwo?~8*_'YFP+F-v{xx%9r#0Wn|<NycM	''-Exao_?(oIy&g   ]B O;*w"'g}x?PkxRb?965)|ukm39^0Lc.^I>9VsuIkun  ^anF]?d|qo2KItx4szW?~8:f}Wvt;S=wg6oGx.Z  3dr7U(LE|E{x0xn.5/fylS+>R~F swem_;y4:e<  Z/d:y9{li,m.-/AGm?wSk%8T[33O'6\F-F'  q7<^hTr3m7\<imXK%O~(L#)6tb~F+27]y  F'zTD^rNhb$|R^Z$FF<]mNwpwe_ZdqHX;;D=,yj]'{  j<Sn#dbG]:"5~f%O"#PB|Yfr~uG}>~Yg9i2/k_/_yHE$@j <  pfwwf)zgT/1n;g2J]dpr~9?3,^u'&jW[Ys?/*\>meg  fo8;RBY2T*dtYr"~pqy.\yy.#%OV4N^?L/~3Wd  Fc5'7tu?M?~(A9-=>,?c~=!^_%[D%YUBeVEgk>|7R  $(x%m2)A|5v!=F>)v[O9<Tw^Zd~ysbG]vdryek>A):<  pvK	_ZykOjXWe87t[qtGl[-"?8"/%  Fi gv#Z<Jg+dkybxOx-?C/94?2G}5V"A)zf(wv>  1?yL:+TPh/T_=pr/{h8/KnS/]<  jLRrmQcmIVWR!<<pV}7IQ>[nROUt1<{St<  LhsO7*rA{gOQti\~(s~V_?gqnvx[jOMV{f>?]O!  lO>Fc+pn^6pWw?,gynXw0>\|Hq|?3?=^-E&{4:<  \v`bT{U]G7-r	#c>w.Nnbj&7DBd|f( z)mSy}o<neYZU_eO%^
+M)I]W=8Eo_"+cVc7,W
+9b  nY/W{m:U2Lo2rg
+Ks+<s?<(<);U<g~:G&=+  |BrsP;B=V3S'r;byZj@V-<  A`
+ytY7}R^U}E">Qdat&r%^W1vV6|!?R  UNq7in_^".Ngd[ECj8/\j"}dsY,K/n?sGN>*xb  \nap{~_R7yv
+of2l(Z_~{GN-g4 K*3S;g>_wrTx1~Ys?gvg^_??Lcgsg{b  afN7s|=@X}DAP^vUmiZGf_o2~~#/>^&~v qd7L>,7NZB
+UW%~("(]L[#Qu"Srz|x}*3S jsE1$
+Em_c]aNOn	R?n#x|Q9T( W;JM.3?kSsB={\K>QnyoM~3OhK~bc62?ov+ j3[t-;v<d>e8i<y;;D^\>9Vlf=JangL'Us!k"l(\]&tqKv$0E'F+<  fU9;@1Y>	L/
+ldMB  R= A),YeV
+*p
+1c5VYU(rykuR]y  FAdPhrAZF>L:cOg|<  !cN.)^}\9i\"&b  _&x2rVpy
+&7$p_k^h/7qp4?.Hd<3YDit.]y  |ZNG?X9/fKN<6gwL\zx0W}c>\	+2~y  |T=rUfh'Nnt
+y3H>!GF2VnYRq}p+?<nQ2/KB63.;/S hDL+}\YUX#3xkjT_ 81n+iDok_A.-oBY?_g?YY~|rTFg2Jh8/fuM$(#4xrTGpdJB|OF'V sO.l>|VN_ )*[4E=SN@YuV
+ZKd9XmG~5'+gXrCjrG39YF SW#gy +mP1yWZd1ybF;3*^w@~8R7~x49S?w	m= P +O~|vi3:lZI"M NHGdO'd\9Pa"_f'J%-gl~O]g]w)YdGd$@B  _pEjJH\/\<
+>mANyA}"%]<6Jk**O3d <MhS"s*3deb^bkG4ROhuY<  VoJ ::'x.O&lqvibxrc6o9$rY$E$]D!-Ra3ZdRgf=WoY(RIInk92;4<^yM#a?eevoIuTKz]X R*Mhk$2Zw	m^,H1|G4;Z)\M"mzA,nek6(Ih,6("d{59Q*I'J%,V'=w&t&b~F=^kzu	U<  `t-Y|C*<Z(=|Qlh4&evrD4>(
+^R;cM"gZDrE{YbHnHE9JQ5S~u#1Ul=;	cDT?Y;Oyiun  *sl= 1GJ,,m4+U?&l%h96+Km35{zudly/]bW"e('%E8X9f[]y  `
+K?#Gg$u-V[p]Bez>N
+z5+5cv#[_n7{;)KutI8QY @UV(/YvW%|
+lY1lc?H4vr"wmVzBJdqM6,N2(%Km?BCnpt9yc
+  AF["5|G8p_rmtxDnCqG] n8a)Pf}p<S%[="-EPO^E.l%%  (<O$"VitK%.]d6quYz.e#W.JF#?t%"-EZKuO.ilgK5a*r8]y0  (ZJK%.:8]~%2p1sm/KFn(9FS\(!NSG/b>"~(a.b6*WOhb`Ny_ @$.l~t!qRpsLuTM4-s]#cy\ }ENthn/F{DA]T[(#NWKvL<U9
+y  w#I'J=@ttWw1u_jW
+`Y]5.Bo#0CR XnY9#sln] 8?'[2m1v94tmcY;-/Ttl !Djo
+>~~
+t,tC65;S^t1*.{tw=Wf%w+,v Pj_g2;[=ek~-*Rvlhi;Z,u!w&D/h|$&K#/t;Z;gbkG1 RnS^9~i~kf2~t9Si3<RD14B6dt
+yrUn=i^:&CsYt@MlWglv Pf*>)38&ykhf+I2M~]Bs\vLbhzxWJ~YuiGmCUmbtDK!g{y V	L"~lK_`NB-HYQr<RzIZ~'(9}xw+/<]BG|owq]g\K}T[&M  Ov$ux-Hd&(!R]rM-EE<+bT$8gDqN#%p5'NmgTYv j_[o('/`dEwNQ;BI*S5INM$X'nu"_M.5?\^qh']9>)kZU:;]y  O5l4Hl9{:-<%h^ )uA65x1bN4)u'Oj]$-tzWJ3m  xR*YKhqi|YzcwTf9WxmBI-;}VjgqKs*6.Mb927ov1L>fw ,ohc4N0Dd{;]7%DNWR_a.l]8xpxVac  ]53"KBGi3}pUK5?6DH%E"t:7 ldKw1bf2JaBStRo~ ?7x=V$/c5Ku'3>~9+U/k(D[Oc:E|^i?xcM)9~}@l;Q&'dlLO4+ [%4Bjtd;z,fe"~(5y3)z8N_Mc;E*mg&T=^.-Ja7\/N*9\[RS  wYiEDd|mT]:.O98LeW>bIoN|-E4igu2Gg+ VB#  CbSOkt[C;[pQ9{(E,,2Wi<[6{A}|m8\3*N r)h}**O65gHp\K~c.sZ"wuG,-.}1?@A|e  W"b)g8u~N][DNhse!:?OLduPqwuuj*=HZbK8AN[erMt,\>/5UTkTP@r:y_ UfLtH0m~R[5kN6BC.)LoF^_SgGag]w pb-$4=7N.	4:cKs  vpIDAT}Et,sHYk B~E:+1*G  lL3/Kr?C9$!wR6~5V.e 9KM,*y0Eb$d:]#KuC^j,=x_fN2Nq	.3D	$]y  R{{8b3^+n):/ pDp,re$sL  Q >Uyf^H|+E/k$+/;*I|}  {,H/f.cyWb~,_[n  [d^HB_q^YU1fv^- fq{U'f+/tF6UG z r/*gbl-g;x? `$K3O7,5:k@J{*  9Q{Ha;@Y}y #ZLA),|-p/9BqjxM(+k41s pjv}^|.f.^J
+1):)<  1n0x/%"2|#  7n\h1})z9PkeN;(D#J1m} [*3SQK)ScxI>|n0kr{WWLRn5:.c=3C6fJHv,4Y _V'ryr#L]"wo+wGXQ)DVjeYKTY0 &v-XI^}t%$+z@q) Af*y9\9P&wn-y<D^=\!odsN.4|_`aQtP]yfI_j-sz6$e_QjmLOWk+r
+ry`|S+kyPv3 .EF
+HLH)1^[y(18b$6|FQ"dwAMk3u2DQ).;R`T9rSRf|>SrrI$b+=qU;+jc=SkS*Y2b?!J9(e 4N%},f^#JLTao29DV[}-jtfzN>:V-[*p6(q%]rZM5Vp1_C1Ux}(5;*]{~]E3y|y[>i['/*x
+KH&DU-= W9OT3<bXeU.29K
+[7sO(?5]}{ ;ZkGRzXHbW+bsN38$O"y7gBLB.4X' <v}"rL,:8S>E$]@!Qn;7|D6D5P>^:
+C<X>?Y#;;p]e
+Jp^Ilpm2x(9I_m8XLTwo5z52C/d]E6:z_b[x(5=uNA]E~>z'-ULam=J,UPRWv~)}|P^K]Uv!@mrvG$K3 _W3 )|B~)eqb>bc;Ea[yah[m@$Qz
+UAQ&>} s,UHG1vZQrv0[~f}5V	h\<Q):Ys he7GqsJ-5nmEgVHP
+4#~OWsP%>} 3,M"zM"zy,^w~/#O\{sl7u\O{@Un~
+_m,KG*~p^KJ5Id&y<r\V!,b79Xke9'XmbBWwcE,rNRG'gNG5+L8JF0!$_*E=Dz rZeo{X@+<Wgww>]y/sI9R?H8z7`O!C-u	$~X%ABwcVT>jw^Y\'ga{OEW4evr,4w)3rMuZX tW4:4j.F2Yo0oHl|Gc[(1<+?*Le2n{P^vT2//+Lx!vv4VOv|{1KMwiE~,fyv`vK0&Ymc""k29nGg)q /*U O(0Q5AlLTzVaBPy
+mnwg{Y$upd]\+<wr@6E_=L(ydWf8+3ZX PibjyrTLIA]T<E,M_*{7Qj[lrt^v_jXx:wrmp>E!N1E}] `v/*]|h{9A)z9Pkv'0e~V?jdxM7E)q
+55$__.yW~j/yc*G[N1F2/ALOl?\zxw~w
+4Spn#v\EN^^H9vqfu^sJ,e_?/2ht\yB\[CdqR4l.EntWv9iaF{g#X{3]_
+yIhYVrFwO)qqn62H6f_vRyD3y1U@cMY]f^wg^=9jr$Ap)=k)qS^:T.1U=myQ#_cR2+U?b9a
+8:5UxHV#7|2eGh8/sL">|ms"7gnB"=1_,(OLaesZnsI,|vy;p6^~WwV?8(qs#E6Hn/7dO2'ns'4S8^o[F9\~">Q^>3]e-{Cj*Vo5&N,9mCvIB^LRe^U~Eh=&Y'5G.z (-99~(Nl~&+"g/_R&}tV>mWLJ~^f&!:hEd$$u^>lTe+ui-2'^^=\!*C)=oo%U!&n0(a5VYoxU9 A)WJeu]khu6{x.wry?J'4&*rF'F>G,z[)S52|7feJ3?;;~;w/2)c/fII"eeu*,Q7h)JIfv5mw{~>Oiu"Rh,Hl5rSbtdcJ|GOemZ4=(v!mr"^*c[ej2eEvVt,0M9Q#|_ZMn	^E^V~Qn|H)JcnT<C!^%iJidb*(s29a/gyi]CueMYjF/V[eMBp6uyp7>cDjK,4%8M>?Y#-P1aE2?R>P&j|z=_yt~ouc,(=I>}e7:+1UN(y	
+rkhxA?B?\=V'_WfCu#??.RrQ"O5T(=V}5VfiYcX'*eg,1Nk6vDNJ|{3m.OhtrQ|eF|ZHBSoD4*u/~;-2'aWPU)w)7:7xH5
+1[V9\htjWW@RthRX#}rK8U#7ie7edZlG~V$lVaQcqTGqoH4xsmN}[m8x?z8[/n/B=%y+zca_)_(U19h=LC;JdHhYJ82C(\fJMUw/9xyHoT bZUhdFOP^*[$0O%fM(FZQ9E^op;:XgSiUN
+y([{fVQ_d$ME7-ssF'3|jm35^W&6x21Wg^i< Rl6*{QE$(jCZ45DLMCUIeCqX+MQfhSQ/jd3E<)$?ershw5t]"Qw-]>>x5=6E;PB-C%]f:Y-PUHfvtPTq]+8^=tN9U3Us^nTK-YeEKV%Vd9K3EIe HD	"ns } E$H"vSsf^kR+Z+~^0t'R=xb|>p}!$*Qv,b9_do;{HUT8wY}8B&[U\},WfPhq|z\z!d'8tU^929DaScFsbpB+uv\M!3#%f^7'nh0GDJk`]mshTt}%)lW> fNo,0HvpOB,iG\IL]9j}DmA6H*\cX;ezA#~ w*' _84NsMWm
+R#Bh<qwxPy%\u}yY*G
+27|F)|rM?Eu\'E$l]0_J'Ovp=B&Ei??|5sO"yu
+[!
+siL1$)1|ZOB/ RAnj c1/8y<Rq_P.)s?hA8Yqk=%?ps</O-e;OqGMN<^"I?W:/NUy=KJUx yx_*c'|KVxF=/xPwe;_rEM=S^=AIS0|6L5^N"7D4yr}1NUQxJII4.3z%WFb^}s3Yj;% VIxyo" pJ<?=8jS k/__mSHfm 6QbSlV)/y5W$>e:?^$[bk?V
+$)v8yP9!k=jI!G^/lVD9W8*CHTpv$E_qu?~7Z'H);@S-zrp?=vuz1giK ${=w9yt1k>+rrX~PUf!/2}xK+dWg%c ["6ns<	Zg|#6Y~|r*yy1p]6J%/EO^r%gggD1g|%W*jaW</Joi^<Sf,glx'dq{U?WI8:]a<^,+/GG`^[aN68?T#</>\ao>>SkHv>-mz_=Uyun|-?N&NL;G6~BZq+&kse?$%s{-9f{%-Yz ^oxec79f8^0Fdd:]$z)7*O~7seI-WE!rT:\HZ?,s`&{Y'v8!Z',$`IM_7UyJWhT[D=G]k)`uz6':[?'@	fSi(:{y*iy]D/S
+GL1/64:$1G|Wjr|yOwq[PS a20Zs p{c@:|2t^/<-^\K6QK=.3{txq?L:Qa6
+s,bR9JcG>yL[%37t8x|-pqprMV/YE5O[\xh'cs|R-\CRc
+!]}C
+?pKjh=f1D-lTi{v.w14FOU>ur=#lsHrUM<z"_w4uDg$mANr
+^$!QioYK&i'
+R")Gl2|| w`7d*sVf'lS6x']kNOM+Fw)))))8rCXRk-:{C(=Y K%a7t^H~|l
+ooTqtAzwU9rHWN7!1'-NHZ&Y:[Y#?8J$[&Y.y(G9w >nv{|PvIfeLjnCnfd+G9{%|*|bCg?L|ySX	MAkRI@/M1dxr|.P"^{"g<;CS%.JIIIIEs,P&7U:N9`z/s ,l!|2)dMTWEo^JgnGdf*O~<^l@y{LYkrHw'G%+bhu5b_lc*4Y.+D)g=<<Ujiy&8ij<3B(
+o[<x^w2?"=>mq0C>b{^/lYy9):Y]rnpa,58$-q~|Ns'Pwp?b`],OTE&sEbfEtRjs KGI,ToTl'C#1u"Po.~W;Cx!_G!k:K'OeGl(Ljll>Accykwy[L2}|gHlA,MLa~B.)WUd;fA&a
+N5WRsEjFP<wGc D;fW
+Ud;EH+i	oaYJ07d CNb'} =*?&)'g0Vgm?)b9'CZWXcmm:]a~pN]On!_eZ+.KgyUeAr!nIbLf|xWOb` *e8M,nO<?Z|72_Z4ef?_ 4EUeEi,vvbQv)1Io/qOGg?~f5 g$bHDUFn
+m"c@F	}sQ$9{p{CxWB)Gw(p?]Xc;vg#V]|dZCs58lk~O.F'^?Cz/~wEz>jE+eb]g!3z}15%Z+.|^>0y]+t%>lr&MEm[
+tJ(wA6e2	"-SqAbG:^;y<+/$UQ\/W1Va>[7^8$3)Fw-C/{|#&N&k67aY}T861v 5	;R|~`]GWgUI+`O=jTp}lhtam
+qbQV)(FVwqi~CW*C+,ffCwzi8k8-1J7t:dhqg&%oYL_nM	o`w>E'$+elt
+cci90Xqmc2x K3)$J1|sg;z&8V%nYj|^in$g0YGtUFan0%K?LE|3-WI]+oVZ.'9&3{Lwa	-L
+kweE
+'.MsOVIZ\^<dBC\!VJsvgqSriBlsLmVEUCsqht0Re]QI?.-sn}Sm;&,leM=~X$U?+N>{HrU )3N7^nlx'|'Ee7DW,3?S"Q7Wk.<p}mMM>g=a3" Kaa+|3bHm
++XRkEgc6n[h	A>d]3mcX.A hcwp<GV`pGKFyIkh&K,(M	\ynsXrk[oIOM)FIncL:Bx?
+3Z!7;%a=d9>Ke~5&N"C:?@)pfmgXsWw~~:ITG+$3-~8J3~?$kqPcQ$!S'W0?(4xFNwfx.k ]Yw0W%9OZ+zqBxPz?mq!?It(#xwsS
+p0
+[g>DOn|=?wk]MghY>z2f.>[!r<]12N&Oh>	vGZ-W7*+]+]+bMuJst	<bCWHE #qH7Cf%{sE jws_rW($mjsR5qB*xBdZ89tw'y7&Cq*i}H\DY{z>jrJA+1X8k:B\&{i^pk?-ckm~+z~9bYDyy]mWah~O!\auBOMNSlG'R6uCr6un-B,%H#d&%3?1c`z.UG?t{fPr],B3[Jd]0r5^l'*w
+-)NY>cP0S`z>%+"[(q3Oz#J6++PE9/LS+p'KodMLgr!_m/B*lltjs'"ue[6L K|#u GqLD^0>4Vk:uAd+$0a!+30^u]y?t{@|cC,EoCpU[$l*V
+g}=1hXSoBKL8G]DVMrcy+Y'M=Q<qVh] ^0zta-1gqR #pEI>Mf
+MH3x	s\p!'
+RLe 
+dqQ7ckg[W4Fj-i6U99E)Y+s$g-G&uv=,M98*3eF\+^Ss9DQi]	;oaZs4xg}]aY'hO. k"S1p'J_zx{yCo:l
+ll+^3#=	kmNow(axqvhb!,lVDe5hb^8?Tvx2ywXOWE#8Q|vj+6Tg/6oVZDp[>mc,`]c{#0:+`:!=j|<bN<wD`@}`?-yi!GXl(.;3"9N#Fw:GC6G
+YZP a'%/Itv(<#.IN:!moxzHW7jBX2'gKjc>{KVp"c 6P.x,a^!fx?/(wF|,FN,R\8WW *'g:AlUcA^;C	S'}|JUua]GiOW{qnOT~6=$q]]>}#s2k;C;;{x;j5&ZOqBXISsl%sxo7yqY[\59K%Q>)_5,cE+3?(>>	j'OIU/_%_y'8y|n4W)QW7-7Sx1ly~9|7/:!f{$jqvum/xsjr5N`E,6L..\p9TXK!K[0]J:o8}>[m]4lf.G2~]stj/^<2Wz"s5><[#:GXN^vwI,mB{z$Ou"X
+Y\}{?An$b`ikqyywF3i_J\1Kw7v%.ixdkpn-"QH#6Q>@ldU=K?~<XlyVeq<%QhBRseYk e}(IoTq]gz.3yRiKt/)Pid&0gH?:nBEz8J5"X
+pd/zikxkw$=:0Os>^\9q^R>OI/G^6n'=(6`0lq$j `)$+s><vSL x<o7P<S^w5D>^l351Nk/^]N"%wwx#&I)"X
+)u 21?^;pMiWs3?rvg'}lB?wYiqpD>jCzmLw.`Z,q|9*KSyA#rFYK%c~<W[.!ss^GR.uTxA?f$3CZNszh7-lLa0|+!
+5RG,hwO?_Kl55m>K}QGwUYx{FwFy4oMisC<N+4W1gc;hv?tJckc M?I?fDvhg+\pn-;O*`6p3ON|j 	o A>DX2gMnbFgs/&N"-{XYgs"g,&>GrtOv2)z\Kb}]
+>V
+<Xlug8] V.Al3Jmb6r+V#D$h8d|UYq[\]Uw;\7_n;{W+q	/|#.yZ\PznL|n^7=C'?tcxw!j]:F6D,skxr0<~]':eZYP|r3Lz/0#6Q<('X2P\uUVd^lWN~t!y4;wnWlM{:[_nB3xZgFjxv{a)y*\e6"/)r+cqD14gkx.\=~*3%8"S~t,Vt~4wgc;c_xd+W0xO(<\?tg1|G[7h9GH:7v(H`/Z`%jL<x6^y{
+,j"sxDLNn8a1+<=.I1B)[_;t%^;lnVyZL_kKLjV(9m ?D;Xz]y}sk=BK[xu#Rq>'+='_er}p9'S<]fq[
+/;27%-,lgk+NTA<\bic!O,aHm
+QlN<PlsKN*<U;M*6c[!.6RT{g_bB1"Wyn;p^~}[|..(HDdhb+j]x['3;!(^kKj#	8b_hR?]rWE/vW"{aAYeVgxf;2Un,]XUgCs,	O@c_YNb]7oLG6GA3C,4U+\7);v$lZ5K$s5^?q[Mw>.Wz",oOq4$:CX4g*)Wy|pJ3t$RM^U0c|fisWt5_m:M_oW&iyv<Qbh,Lidh7
+#;wp+4J^kaj@vJeEs4x/zHYn`T}u<Rj-l@H?w`e>^[M&xQ<^mF\&ub[q_ =A*yupFFy902h1G
+:K N\G2GQg~_.S+X6h?5ADkIhaCOU}:\^H$oky172d!xdq^~PbnQBBt^k+5.<Pd,4{	8Qi xYWrQ.CNoeQ4]K,1*FuD;;\`V4"3Rqf$[T(ph&V^_9,iaXySpj'l<
+86uj'oH2Wz,"[1f{n ^ _9FYp/1W`.Xi{MR]a!Ot*pl8>q6#t*GxfN`%E_`K=+Zy6~J7-l.Jbx%;5nDp&be]<H\xgxit L1OD
+|'=![xq>#iFnLSd!OtDvD.Ia7^}!QDAL<G	8?oc'q~I$7hrSR#X7`y0WMg.w.0rcF3*Px#I,./,O#xwqE&;J!e/&hBqES 1HIt=X&UMCxvpfD_nW]jEV<Vs5>o:j	&u2'e+{uxtX#0W~}*OacOW}:sQR\=oC<YKuC[+NrE _y[~g_;nu9Z6X*1cITQ"	'btQ`q>=.92UiwX@OW{|v='c`L|J!_9:AS:?%6e]r:Kk,q>?ybM0(6tsg5]vi\=\h#<Y#[@?]=a/xU[(<#f7y6{]UDc<
+}Io3n=Lr6&sxjv`.m	 Et.KkIU|A |;pwWRBNujwPlbq4Xh0{4+2Uqx7#{r=%-_82Tp3tvzcMxy{uN6c=5ZtXOVzDyf]Y-\Ft7+-X/"iis'Vg5Z+U+Ggj7yry)pv%.{ta7^Z VQuDxpkhr6?"+}inc1.r'p[90y.CN<UUd&9cs$|5q>%*\?qnJum#5NHI:g<IW':=?_g6<U+GY88RR^,	_;~"+hyuQg="Kb!ORg	`cgs<3s7&gM.+H^6	rtig}zR*B:.9A\Gxk}xqDFWC<?W_Kl%kwkqQ2?m+||`,IX};3uGv`I_P`cjT:)n5h7CN]`M{4"S
+-k%v.Yx6bM;s276qF}ZX3+pExE[GA'-9w?p/?_f+3Jb]<&,Bk[GS;b~lNi'yIir;"qh CNk5lB7R3N;}k$@z?2Uxg;yTQ'dc!/hI&lnsAKII`b[-4Yjggf<T[Nv_*c,re"f;2+l"?Fc^_Mx>lbiq/6Led [O#zW+p}63{tgN..B-r'wIxmXw0rIX3?f}'j%skN%t/^<d,uT1&t8]0YSbcov|<da>3Y2'Qwj$@/Z]0.KWbEE6}a_nW=:<Tu:6N-B~9~K$g<=^rbC[[%B95+y2_T_IR5y/Wq[?3\]f<=>sLb<-wxy^'\1
+xwx<3MR8s$5'J6lnsajG-A{et|KL<,Nn7N1I1M72?wp7w2_)Y6HBqoOXaNx/iY)\{<-jS /2q,Q.IW\-yHSIy#kI"kjZz{2O,i1?U&\K}{}!w6-vUe0g|#=MVX(n4{Cx@1]sM Zh.lbMLX33 ,1$nZ?'DGf<v76tYrEh![](b}I|\Slg!<9i3-+j/n'>y:# Z9,wTFojLRjSf;{8iG&L{% n3%6<_+9rQ`q_c@r>=sQIuOh!`!-w34Ac6c3
+^d@|>Ghpg79659p)}Oj9{[e6^	PIeQy23Yj)xaD-Wz$s6u QBo
+S3xq?W%>|`ypI*ytvX9%)vN7Q^^t6i^O?pk?n.lQFPzm%vLgzCpExnDH&U4c	Ovf|EA'pt 0y"XSosxFPh\wxu,dYk #<7O"|ALYocO)w ^sEX9BW'%^fF:RyP-V'I|7?pOOUyDqPRJ\qo}]}chA<Qq,[u|s,Y3h'xID.JS]S`#x'y=<v7,f6TGO~"@PBc
+%),yG
+l-n72;^cfrs|;-~n:Wp?#)(y<#xn\i"S[PxN('E ?9@
+<-m=^sQ? G9K`aZ#@o
+e)Xgz'H\adh}whFT6q"HtVoH	_|pt%YX`G/&]p
+-)s\e!?K[HWyW*_v<`nPu ;u h18CXSo'ON&0ZJ?gAB_(o&vgN;U1W?ZJ7^.lCoi,<NBn!rq,5 Gp\o@DQm,Qeu{0y:K Wf#A]
+b"Q~wS(}Qm
+|sE 4@="VBw
+),]loMH,5AAJ7<{
+jR=8,)q\q,
+JUeZ\SrBx>cb7VCB[)pn&txNnpzw;GtJ$wxbc\yh.MT[D>Nng!<g8~Xdz]`?*\x(-X7Q7NvK.@jUvxb#@5WY3b$:(4?8+wq^/hx&q|?0yJ}>\3)W[|S(wzL6kH4#xP"S[pOUy3gInBn)r^@9w]!ch9"rqxyITRl|GF]gfAgOWZS`e<[*I	O3]p
+KBSC:_3&h]Pvz;=xVv3b+?[\eg*bs: Ql\6EbHK'_t/RBJ\'	*`iYM2q^=-*n ,J(poP3C,I:a<Y@#9Q|9<u>yYut$qz?L^c <qW9I`-/KStNuf'l/w)tLQyFHgmD2a;05v=;Wdc.V?a!3D'[13xdl{[<nWq<#n<;<QKCX}mwOw?~Ivg)t$GFJt;XSoQ?`3WKx=yFh)1LSt8(wp59V4Z\9KQnz,bbwE[bHm
+E8qu'Q}pm	sFSgB(lSe}'$; 	|}
+)X,IZ~^'wt%>jr$:BA(H"!*0r5a!z^:m$X,RRRRR!I`c9f	%IO
+m[t }~5H
+t~\=D^<da(?FiZj@y
+,zF<di"ZPB0yxe`114cO8I\!c
+#LIDB`LbY+&F<)^sIv5HU4Wn6a,4~9t(S%F+ Ge tz"GAf8B|iQhEvBz`	qU(.
+-Px'u~|~SX#rt
+)ZrV";::j<#fwE8]pDXcx(y"j^-q(KmcQ>Ou
+8,IFM\s@% i@Pjs-!QR|_{ee[)aNC%|ITS3.S93"I7%T!eQdBm
+8l\}'RElpv$zC.k93'J{8-[%5A9uq$c(M^Z+TCQ$) PfU<+\'J=:3 L1zlf'@ONG5UcZld Hc5;sW8nD))))J_![O[\p|c/hg)E""W~./VN7F67#,kp&Z,j$]F`Y@:n' ,J<C;Xcq|Fs,'Zky#M!6,iq/Z]fv=12aoa9nh:,AW&i;rKxs)_5Fh1L`>Um,fD1 ;t$C&(,mtIZ<xg_Wj>QYx\EFCN5;3Ojs \'WtNFg^f_$W?Vl@H <)3IY2  Nr a5[~ w9wH=W}jpdIHC4G*nb'k;w4kw]*?kUrD!14SEv?T EFgow(%S?Uj~$qHmc3|Ydi"@%Ra 2}$cs_=f5Wf;_Uyc"Z"^*oVZO_Hzl8YbX[N5f~FF'!ZPz(oFqLqyAt.fYnm(Wn$#)g$vpUhj<3l6O4=DoSC_
+R,'&3E#s	t25n9?yEa.m
+lp iUYCX9Ov"DwNl!^DDvlU~pDPs5>;(0`'J/Z].+hEgCWNROp``smG1DQ'6#"obu{&cID)))))_q;lL'{Z9fkSD))}C UQREY_D09SsxnDIepnD@ha.B1XCUc@ v5vNlmw_("J{8Rs+2O!WI+V?!DBLQT*i!0Dusr J0@"vpJn/US5l`G$D*p!"QMKVsUdb WHx6k@""&"\|>ut$	 JlA$d)B;1_Gr*Iw0_xecWV[%jS 1$9zfs_IWw/<t6(gWHM19zb]!g!qX9ly>W%yV5_EEFwXEQ/;bBDN?%-{rUx{BpFxmns1dOD>$_jv`D$R x""'Ero\!X?b 4XC,{sZE|"/y-~^7'E9IKL/w+Y(8/}`Ky6^YAK.'^WE|gfD!k{K(}jP3#IM9 
+T'"]x~s#iqh: r}.~*5Brxg!G!YIk.G8-O4-1aie$".!|dO$i>UQbx#xJ$#k:4XDD`1
+hadSw 	_%6+_P
+<7*ux5m.-uIux"YUglDc@[A$\;TIs7DCGE]4=:>)g G8u0]\'nwDEPz6{>YUy9$"kP>J"{("vG8FD{Ky46aTs$g!t<(_D5x	 8J}a,8wxbeJA9!UDD"We&]	@m/"mz": $3mX7NiF'9oR?*;/d>+D4# x""sa/x~s".rBBODt~rTF&':DDv:^[Gh!Sqv\jWFON(18V_|(|{B8KDe4_9W&m.Qykp5~N[QcgOD3*"j1""J)4-T~)BO)q>efe[xf~TpEu9)*cXJo`dgg:(IDst{Fp|11gb^Cn#q'B#x"uz8yF3Ou-Z_l//CDsEW?[nG#GL8YZvs5\h'
+[r "9qFHWE[<Cs--BS/Y#`
+n50q_2h|Rh"q6;-K[--kUQ']aM1M(si|NdYk (0YTL'0O53h!lPq"_ag
+"ZDk5<:1_?^xE	PD2}*huq#"iv>6Ws q4w|W3.D 7V	c%Q|~s<u :gBXg+RODDu5GRwxAk\v/*10Dpd
+q2\`\|LA|^XQrl
+,])K],cRl_:%u"",{8l
+Um\YmATGXQmns	H""C`iY43D9?E%"|/OHL!dDD$.h{B__IDD_-0Fx	'-N8>h&ytxC:"3H`\DADD$	Gcdjs $k:?)3&ZqikG0>DD$)1,oV1m0$%k;"t(,5r$""*5]:PI?UmAA(5 M""V3kD+ F$1[PEf~l#O' \rKLr*(>D!busDD$?	lQElM;;,!D$NzI/_j<[Ey`&uNDB~QQJJJJ{DeNbHl
+0;DKy6E[1\vU#"&[(|M&$L}CnniK y(8N"d898LC|l#-06#"i{PB^ODD4S#_MAN ]!B\'"ywsp%""V	|GdAh\|Hv.Hh!oi(|:SXVK^}L0Aiks+aEvDDD$W
+g!R&-9|v'"JIIIIkfvr%""ZBp% &Nu~Wr%""Z$*~''=\d6qOzDD^"~{c/QO`mG0}p$e29ohy[b>E<Q5v~cKbx")Zh6l!wgoVDDDfa]W{V~mnWmh]DDDBE4^c	{Xv"0B"km8`"""N"b}&
+hf84&9x"EVo"G9<l,{oHZ'eAnV8K[	-N/Wfc,MIG+-;s-V """""+_,~A1e}01}alKZPBx(	)SX>}pbkc:;X7o_hF'+f;s3'QhPO.}DDDDDD	QPB/_o?D=V(Ql&Z&sQa=yH].v6$"""""Jo4_hvco
+O`68cxAlpd)	kr@ ;s<z<'=!c0'YohA7D#"""""VY6q-WqAd#h>W/0DDDDDDBSma|r8wW#0uu=a,Coa u	Mlu;4(>aMcG?-i?,i	`Ek5[
+""""""1)wkO=BG.3WWqHW"q/AnbYeE,k=0vi"s0p+Z%}!('8x""""""BjN=BS[a|vI/5W$<368}]}#lP+ZOkMjs {lrGDDDDD$U1|X?4=hs58(2_sm+ZHDfs^>9e<?]_+HlG&=8b>Cah3u0pyU@""""""Q*5]]r7[iWVk{ 6 \8DDDDDD"U[DPm;655WO\SE7:bdh]O7i	AgpgscM;c!wu{O;Il
+#/f
+lt@DDDDD$)ZYKv&xk8{ey#"""""o|js e>h9""""""BB~W=%-yM`w_<hl>x66 """""1^O2s%& """""N82lr.
+	,=A8q!dE!0 #10:PQL>~M{	iOm`g#E;:mg+PO'""""""&8L0x""""""")1ht-W'S9lA'""""""gtH6vNYx"""""""ArXSAXC\'""""""$c`N\=%|W8~|js VJbE~U[q	bxFfODDDDDD$tqnbpd<Yb'""""""JT~B 
+q   jeXIfII*    	                  z                        (       1       2             H      H      GIMP 2.10.22  2021:03:05 11:30:11                                                      K          JFIF       C 		
+ $.' ",#(7),01444'9=82<.342 C			2!!22222222222222222222222222222222222222222222222222   "            	
+    } !1AQa"q2#BR$3br	
+%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz        	
+   w !1AQaq"2B	#3Rbr
+$4%&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz   ? (
+(
+(
+(
+(
+(
+(*cI=W7q9|@1cEy]1Svkk;$z98gZ1[-E" A= ( ( ( ( ( ( ( ( ( ( ( ( ( ]+	U_im>4jr?
+$'$I^ |I;/}O018 /~q= <Wy^V*%KgJuQEuQ@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@Q@r+f ^I(G8D^wyrr?Wlv>gQE(WM3_^D2yo~' ~U"7:pgeEW} QE QE QE QE QE QE QE QE QE QXqQ{ 9QnrS;Pin`4FYIPC)XQE ax[U?<Q \}]~09@vUa:iu>{WmlQEls*;FHe9v4PX]Wc{)kIfO_WW^%z~n'aZj]B(((((((((vZL ^1/yBW}s^FFx!>}pW<LmH?&x/IyA*A:^B[+n
+W+n`"6+zzVa9/jRm6}KDO<yik%jUveU+,l7c1:c\es3]TVz3FwZ!+s( t3F+n9{WVHQu#x!RRW _qBU_x 
+f}&liso /%ePv+F+Id#V9{p7G;sm/ h
+qVy4I(O"5 =4PRM [W6bLIF=VUktaqrv41'+=( ( ( ( ( ,ST@v=r^\-wPd0?]j<<my>0N~izAmwcc{rJN)#y~dn=T 3z(vQKbsIOFO]z'OCRlveCM*tjW !M(;Hc/O~5qDOeQVfQE Jku+}BqWjux[4NTQA
+r?>++#0)o\\$K>pC]r^X>O mQ~_?*i>/(C( ( ( ( ( +<w+zAIaUbkf4L9V*{9Kq7v0(:0*t:Oip ~WNj+J2+IjG^ha.A{=k;=R6eW;SRLAQTHQE QE QE#2v
+2I8 P\ncV|zA^jD77RxcRM)_i7`F|:yS*Fi8y| Q-v=GO-Dsn YW(.U7e}[Z$.#F Ewv{J*(C
+(
+(
+(
+(
+(
+($1Kvi`rO.jPPv>X#gkdP{-^Qed^~}Cz?$H$\2qWy{mad1_`;_^_K]%4c0/S:|64-j $B>W'M_jQo(#.?_w$7SvSJ+7ntE8Gaj[;A|A}2gf8.+Re;p"-Gk etaGqBa(bk'nDkS.NcXQ>X{5$DM\n?u\NO0&'?+{CkC|*ub1y1(h_=i2w-.DJd9RU<-gsGq*MmASMQXQ@Q@Q@Q@Q@Q@bxP5{?u{
+J'9Nw8>U*QN6xa(zS;3\Zy}vyumVF$YW_vJP.aa?+z8bG!JkmN ySX{hGewsKzNr:~5U@(zSG,z
+Rz'x2jO0\w?*5YO/iWV dAm*PE#R[z]&k 
+1Z8oQ* #:)	s~en)H" `s[ZDTUZFT?u*J*@sX5D9_TOyeEiWM<J,F#J./CK!]Hg998>6f<g0v*;3gJ8HhISEz_YEpnCW,\Z.7+*1ui}EQE QE QE QE QE QHK1 I=<qYk/vo]:ss:I^nM~yy|v_J#J49O[r(b*H>+2T}+ZO$20Q34"bkO _ojtnJ+_L0rpOfCd?JZ%kxh>nkQEwdjV\j<b1}kJs69(0y>uV>t[I;{;VdpHe9v4V)'7rKAM'5.MH}W$&OZh9XXd;|HW7OY:7_ ? Yyh?S Y	}bfG?2]MjxB!b{I \4d?{)U{vO8sGg;O=Y]C#S Z-WR%?dSwvJv*}>v5lJk:dYEc#-w|~?38BS|ZEN-4Q; k#ZKO6LJPn7JvB"Z<j
+^gk^0t[4Glb!5"2x>TN	{6:@|7hQ/'y9w9&)b#48'-l,*QVf(%H#;vg J\`t+
+dt[w7Qv-k7B? J>vv++9'$_b$j5/?^GToDiBN;wu
+z.:|E$L1q?J-/I*,w83$6.ZT) f?  vVE+8W={r "]BUS1|3eg<>A/
+0(%/7=y%6r LV_#	$Lh T*sGMo:^JHFUE+j'X/B+J6Q1M <g#]2w2 pk~Y>qzML6k}a2{Xb u*yggqE{MOF pQ{\I*)
+v5)4H,p 5_mVM6~@o~S\w^\4?,K/)`*OYh:iFt16Fql|';?%IX%YnAzV[l?8eZVeZ{(/Vc9'tKMJXZeeZ|IiMp@i7^A?q .>?Y-HS {QB|?O6+Qh7[./c+ +3WI^KDac.2OJiFH>\-gv W?Tg-7ZGcBOT"BT\"
+6f \u15My$sWd
+!'~$KEQ)GckQHvu+~0n>C?S{Vi]kIPZi}I8Ct<#-s?O%- Rw#^F^]oA@?3]vcs 9pw~/ZcfE\2*zBRQlqkH0F )Q\pQEQt-s{y'c QrvBU3VMkRKyfO~Ob9R"bqyBjV6o B: ^e=:+)=xHxNZ*MA B SoX<?)  nM-g*cb?0lY)%8"M F>zM%kT)e$(1--OWQ	#DqT~>pAHzT`c#)\uq0pcz<5= e!8;#}yHL?3OCGX^EW9s>0klp7oj+Q J8q^GZgJ<]v+.^\onGGkq7dl{Ny`J*cdz+J'GF)r9[7U>x2~
+(I1F|Z-}Q>PG db}w11g:*f;AiUYI>V[YRNI<5(Qy11|K	%pT(cVJQ'u MRQLX#A dCZvG>;;JfL8y>#@uBJ"Os^
+Q&d]4oj'a?7,V-MpF}?#bKo&a85$TE
+ ~rh9uj?<Om}6+u krm 1hYckIv.[G[|8WKPk~1Q-EKV  p3T+8.%n\m?w	$<*BMhW+smfYarFS$:q\5[Z9;A{>"3tzu5t` ^9Q@(Ojf20}9(:89>;PgScg' d="#?o(RMJm+bU 95c=#<;WMeZX. ,\UqkQe aoQEqJNNcEX(EQ@y_|RirDfSWWm[n.G?E<??{W 3K>mdbQOoz;{xm`H-XAE($$T UU b%ZW{v;XahQ\PQE QE R2+WPz2-}[0I9SvnI$) = ~5 WU<TuTjgQ] n >Sv+.uO^,D*mV_P`k)Zk-.^;wpL$2<9$+(]j[L-x_tu9d'P%v/`?vn"uqU4cr=a
+USqZFhxnz?'*VF
+VAETQE QE QE `x0M	;.AAz7|=Z,IJ>wSU=EVfEPEPEPEPEPHC) KE s!2Y?t Wo:un#}=dY#]T%>zZ?d@rQEsG !k   %tEXtdate:create 2021-05-14T09:45:53+00:00   %tEXtdate:modify 2021-05-14T09:45:53+00:00'   tEXtexif:BitsPerSample 8, 8, 8>'   !tEXtexif:DateTime 2021:03:05 11:30:11+.   tEXtexif:ImageLength 948=5   tEXtexif:ImageWidth 1010 K   tEXtexif:Software GIMP 2.10.22   &tEXticc:copyright No copyright, use freely   tEXticc:description sRGB built-in    IENDB`
\ No newline at end of file
diff --color -Naru uwufetch-2.1/uwufetch.c uwufetch-2.2/uwufetch.c
--- uwufetch-2.1/uwufetch.c	2023-02-13 15:38:44.000000000 +0300
+++ uwufetch-2.2/uwufetch.c	2025-09-13 19:57:29.376368231 +0300
@@ -14,7 +14,7 @@
  */
 
 #ifndef UWUFETCH_VERSION
-	#define UWUFETCH_VERSION "unkown" // needs to be changed by the build script
+  #define UWUFETCH_VERSION "unkown" // needs to be changed by the build script
 #endif
 
 #define _GNU_SOURCE // for strcasestr
@@ -39,10 +39,10 @@
 #define LPINK "\x1b[38;5;213m"
 
 #ifdef _WIN32
-	#define BLOCK_CHAR "\xdb"			// block char for colors
+  #define BLOCK_CHAR "\xdb"     // block char for colors
 char* MOVE_CURSOR = "\033[21C"; // moves the cursor after printing the image or the ascii logo
 #else
-	#define BLOCK_CHAR "\u2587"
+  #define BLOCK_CHAR "\u2587"
 char* MOVE_CURSOR = "\033[18C";
 #endif // _WIN32
 
@@ -52,584 +52,628 @@
 
 // all configuration flags available
 struct configuration {
-	struct flags show; // all true by default
-	bool show_image,	 // false by default
-			show_colors;	 // true by default
-	int show_gpu[256]; // if show_gpu[0] == -2, all gpus are shown, if == -3 no gpu is shown
+  struct flags show; // all true by default
+  bool show_image,   // false by default
+      show_colors;   // true by default
+  bool show_gpu[256];
+  bool show_gpus; // global gpu toggle
 };
 
 // user's config stored on the disk
 struct user_config {
-	char *config_directory, // configuration directory name
-			*cache_content;			// cache file content
-	int read_enabled, write_enabled;
+  char *config_directory, // configuration directory name
+      *cache_content;     // cache file content
+  int read_enabled, write_enabled;
 };
 
 // reads the config file
 struct configuration parse_config(struct info* user_info, struct user_config* user_config_file) {
-	LOG_I("parsing config");
-	char buffer[256]; // buffer for the current line
-	// enabling all flags by default
-	struct configuration config_flags;
-	memset(&config_flags, true, sizeof(config_flags));
-	memset(&config_flags.show_gpu, -1, 256 * sizeof(int)); // -1 means 'undefined'
-	config_flags.show_gpu[0] = -2;												 // show all gpus
-	config_flags.show_image	 = false;
-	FILE* config						 = NULL;									// config file pointer
-	if (user_config_file->config_directory == NULL) { // if config directory is not set, try to open the default
-		if (getenv("HOME") != NULL) {
-			char homedir[512];
-			sprintf(homedir, "%s/.config/uwufetch/config", getenv("HOME"));
-			LOG_V(homedir);
-			config = fopen(homedir, "r");
-			if (!config) {
-				if (getenv("PREFIX") != NULL) {
-					char prefixed_etc[512];
-					sprintf(prefixed_etc, "%s/etc/uwufetch/config", getenv("PREFIX"));
-					LOG_V(prefixed_etc);
-					config = fopen(prefixed_etc, "r");
-				} else
-					config = fopen("/etc/uwufetch/config", "r");
-			}
-		}
-	} else
-		config = fopen(user_config_file->config_directory, "r");
-	if (config == NULL) return config_flags; // if config file does not exist, return the defaults
-
-	int gpu_cfg_count = 0;
-
-	// reading the config file
-	while (fgets(buffer, sizeof(buffer), config)) {
-		sscanf(buffer, "distro=%s", user_info->os_name);
-		if (sscanf(buffer, "image=\"%[^\"]\"", user_info->image_name)) {
-			if (user_info->image_name[0] == '~') {																													// replacing the ~ character with the home directory
-				memmove(&user_info->image_name[0], &user_info->image_name[1], strlen(user_info->image_name)); // remove the first char
-				char temp[128] = "/home/";
-				strcat(temp, user_info->user);
-				strcat(temp, user_info->image_name);
-				sprintf(user_info->image_name, "%s", temp);
-			}
-			config_flags.show_image = 1; // enable the image flag
-		}
-
-		// reading other values
-		if (sscanf(buffer, "user=%[truefalse]", buffer)) {
-			config_flags.show.user = !strcmp(buffer, "true");
-			LOG_V(config_flags.show.user);
-		}
-		if (sscanf(buffer, "os=%[truefalse]", buffer)) {
-			config_flags.show.os = strcmp(buffer, "false");
-			LOG_V(config_flags.show.os);
-		}
-		if (sscanf(buffer, "host=%[truefalse]", buffer)) {
-			config_flags.show.model = strcmp(buffer, "false");
-			LOG_V(config_flags.show.model);
-		}
-		if (sscanf(buffer, "kernel=%[truefalse]", buffer)) {
-			config_flags.show.kernel = strcmp(buffer, "false");
-			LOG_V(config_flags.show.kernel);
-		}
-		if (sscanf(buffer, "cpu=%[truefalse]", buffer)) {
-			config_flags.show.cpu = strcmp(buffer, "false");
-			LOG_V(config_flags.show.cpu);
-		}
-		if (sscanf(buffer, "gpu=%d", &config_flags.show_gpu[gpu_cfg_count])) {
-			gpu_cfg_count++; // enabling single gpu
-			if (sscanf(buffer, "gpu=%[truefalse]", buffer)) {
-				if (strcmp(buffer, "false") == 0) config_flags.show_gpu[0] = -3; // enabling/disabling all gpus
-				LOG_V(config_flags.show_gpu[gpu_cfg_count]);
-			}
-		}
-		if (sscanf(buffer, "ram=%[truefalse]", buffer)) {
-			config_flags.show.ram = strcmp(buffer, "false");
-			LOG_V(config_flags.show.ram);
-		}
-		if (sscanf(buffer, "resolution=%[truefalse]", buffer)) {
-			config_flags.show.resolution = strcmp(buffer, "false");
-			LOG_V(config_flags.show.resolution);
-		}
-		if (sscanf(buffer, "shell=%[truefalse]", buffer)) {
-			config_flags.show.shell = strcmp(buffer, "false");
-			LOG_V(config_flags.show.shell);
-		}
-		if (sscanf(buffer, "pkgs=%[truefalse]", buffer)) {
-			config_flags.show.pkgs = strcmp(buffer, "false");
-			LOG_V(config_flags.show.pkgs);
-		}
-		if (sscanf(buffer, "uptime=%[truefalse]", buffer)) {
-			config_flags.show.uptime = strcmp(buffer, "false");
-			LOG_V(config_flags.show.uptime);
-		}
-		if (sscanf(buffer, "colors=%[truefalse]", buffer)) {
-			config_flags.show_colors = strcmp(buffer, "false");
-			LOG_V(config_flags.show_colors);
-		}
-	}
-	LOG_V(user_info->os_name);
-	LOG_V(user_info->image_name);
-	fclose(config);
-	config_flags.show.gpu = (config_flags.show_gpu[0] == -3);
-	return config_flags;
+  LOG_I("parsing config");
+  char buffer[256]; // buffer for the current line
+  // enabling all flags by default
+  struct configuration config_flags;
+  memset(&config_flags, true, sizeof(config_flags));
+
+  config_flags.show_image = false;
+
+  FILE* config = NULL; // config file pointer
+
+  if (user_config_file->config_directory == NULL) { // if config directory is not set, try to open the default
+    if (getenv("HOME") != NULL) {
+      char homedir[512];
+      sprintf(homedir, "%s/.config/uwufetch/config", getenv("HOME"));
+      LOG_V(homedir);
+      config = fopen(homedir, "r");
+      if (!config) {
+        if (getenv("PREFIX") != NULL) {
+          char prefixed_etc[512];
+          sprintf(prefixed_etc, "%s/etc/uwufetch/config", getenv("PREFIX"));
+          LOG_V(prefixed_etc);
+          config = fopen(prefixed_etc, "r");
+        } else
+          config = fopen("/etc/uwufetch/config", "r");
+      }
+    }
+  } else
+    config = fopen(user_config_file->config_directory, "r");
+  if (config == NULL) return config_flags; // if config file does not exist, return the defaults
+
+  int gpu_cfg_count = 0;
+
+  // reading the config file
+  while (fgets(buffer, sizeof(buffer), config)) {
+    sscanf(buffer, "distro=%s", user_info->os_name);
+    if (sscanf(buffer, "image=\"%[^\"]\"", user_info->image_name)) {
+      if (user_info->image_name[0] == '~') {                                                          // replacing the ~ character with the home directory
+        memmove(&user_info->image_name[0], &user_info->image_name[1], strlen(user_info->image_name)); // remove the first char
+        char temp[128] = "/home/";
+        strcat(temp, user_info->user);
+        strcat(temp, user_info->image_name);
+        sprintf(user_info->image_name, "%s", temp);
+      }
+      config_flags.show_image = 1; // enable the image flag
+    }
+
+    // reading other values
+    if (sscanf(buffer, "user=%[truefalse]", buffer)) {
+      config_flags.show.user = !strcmp(buffer, "true");
+      LOG_V(config_flags.show.user);
+    }
+    if (sscanf(buffer, "os=%[truefalse]", buffer)) {
+      config_flags.show.os = strcmp(buffer, "false");
+      LOG_V(config_flags.show.os);
+    }
+    if (sscanf(buffer, "host=%[truefalse]", buffer)) {
+      config_flags.show.model = strcmp(buffer, "false");
+      LOG_V(config_flags.show.model);
+    }
+    if (sscanf(buffer, "kernel=%[truefalse]", buffer)) {
+      config_flags.show.kernel = strcmp(buffer, "false");
+      LOG_V(config_flags.show.kernel);
+    }
+    if (sscanf(buffer, "cpu=%[truefalse]", buffer)) {
+      config_flags.show.cpu = strcmp(buffer, "false");
+      LOG_V(config_flags.show.cpu);
+    }
+    if (sscanf(buffer, "gpu=%d", &gpu_cfg_count)) {
+      if (gpu_cfg_count > 255) {
+        LOG_E("gpu config index is too high, setting it to 255");
+        gpu_cfg_count = 255;
+      } else if (gpu_cfg_count < 0) {
+        LOG_E("gpu config index is too low, setting it to 0");
+        gpu_cfg_count = 0;
+      }
+      config_flags.show_gpu[gpu_cfg_count] = false;
+      LOG_V(config_flags.show_gpu[gpu_cfg_count]);
+    }
+    if (sscanf(buffer, "gpus=%[truefalse]", buffer)) { // global gpu toggle
+      if (strcmp(buffer, "false") == 0) {
+        config_flags.show_gpus = false;
+        config_flags.show.gpu  = false; // enable getting gpu info
+      } else {
+        config_flags.show_gpus = true;
+        config_flags.show.gpu  = true;
+      }
+      LOG_V(config_flags.show_gpus);
+      LOG_V(config_flags.show.gpu);
+    }
+    if (sscanf(buffer, "ram=%[truefalse]", buffer)) {
+      config_flags.show.ram = strcmp(buffer, "false");
+      LOG_V(config_flags.show.ram);
+    }
+    if (sscanf(buffer, "resolution=%[truefalse]", buffer)) {
+      config_flags.show.resolution = strcmp(buffer, "false");
+      LOG_V(config_flags.show.resolution);
+    }
+    if (sscanf(buffer, "shell=%[truefalse]", buffer)) {
+      config_flags.show.shell = strcmp(buffer, "false");
+      LOG_V(config_flags.show.shell);
+    }
+    if (sscanf(buffer, "pkgs=%[truefalse]", buffer)) {
+      config_flags.show.pkgs = strcmp(buffer, "false");
+      LOG_V(config_flags.show.pkgs);
+    }
+    if (sscanf(buffer, "uptime=%[truefalse]", buffer)) {
+      config_flags.show.uptime = strcmp(buffer, "false");
+      LOG_V(config_flags.show.uptime);
+    }
+    if (sscanf(buffer, "colors=%[truefalse]", buffer)) {
+      config_flags.show_colors = strcmp(buffer, "false");
+      LOG_V(config_flags.show_colors);
+    }
+  }
+  LOG_V(user_info->os_name);
+  LOG_V(user_info->image_name);
+  fclose(config);
+  return config_flags;
 }
 
 // prints logo (as an image) of the given system.
 int print_image(struct info* user_info) {
-	LOG_I("printing image");
+  LOG_I("printing image");
 #ifndef __IPHONE__
-	char command[256];
-	if (strlen(user_info->image_name) < 1) {
-		char* repl_str = strcmp(user_info->os_name, "android") == 0 ? "/data/data/com.termux/files/usr/lib/uwufetch/%s.png"
-										 : strcmp(user_info->os_name, "macos") == 0 ? "/usr/local/lib/uwufetch/%s.png"
-																																: "/usr/lib/uwufetch/%s.png";
-		sprintf(user_info->image_name, repl_str, user_info->os_name); // image command for android
-		LOG_V(user_info->image_name);
-	}
-	sprintf(command, "viu -t -w 18 -h 9 %s 2> /dev/null", user_info->image_name); // creating the command to show the image
-	LOG_V(command);
-	if (system(command) != 0) // if viu is not installed or the image is missing
-		printf("\033[0E\033[3C%s\n"
-					 "   There was an\n"
-					 "    error: viu\n"
-					 "  is not installed\n"
-					 " or the image file\n"
-					 "   was not found\n"
-					 "   see IMAGES.md\n"
-					 "   for more info.\n\n",
-					 RED);
+  char command[256];
+  if (strlen(user_info->image_name) < 1) {
+    char* repl_str = strcmp(user_info->os_name, "android") == 0 ? "/data/data/com.termux/files/usr/lib/uwufetch/%s.png"
+                     : strcmp(user_info->os_name, "macos") == 0 ? "/usr/local/lib/uwufetch/%s.png"
+                                                                : "/usr/lib/uwufetch/%s.png";
+    sprintf(user_info->image_name, repl_str, user_info->os_name); // image command for android
+    LOG_V(user_info->image_name);
+  }
+  sprintf(command, "viu -t -w 18 -h 9 %s 2> /dev/null", user_info->image_name); // creating the command to show the image
+  LOG_V(command);
+  if (system(command) != 0) // if viu is not installed or the image is missing
+    printf("\033[0E\033[3C%s\n"
+           "   There was an\n"
+           "    error: viu\n"
+           "  is not installed\n"
+           " or the image file\n"
+           "   was not found\n"
+           "   see IMAGES.md\n"
+           "   for more info.\n\n",
+           RED);
 #else
-	// unfortunately, the iOS stdlib does not have system(); because it reports that it is not available under iOS during compilation
-	printf("\033[0E\033[3C%s\n"
-				 "   There was an\n"
-				 "   error: images\n"
-				 "   are currently\n"
-				 "  disabled on iOS.\n\n",
-				 RED);
+  // unfortunately, the iOS stdlib does not have system(); because it reports that it is not available under iOS during compilation
+  printf("\033[0E\033[3C%s\n"
+         "   There was an\n"
+         "   error: images\n"
+         "   are currently\n"
+         "  disabled on iOS.\n\n",
+         RED);
 #endif
-	return 9;
+  return 9;
 }
 
 // Replaces all terms in a string with another term.
 void replace(char* original, char* search, char* replacer) {
-	char* ch;
-	char buffer[1024];
-	while ((ch = strstr(original, search))) {
-		ch = strstr(original, search);
-		strncpy(buffer, original, ch - original);
-		buffer[ch - original] = 0;
-		sprintf(buffer + (ch - original), "%s%s", replacer, ch + strlen(search));
-		original[0] = 0;
-		strcpy(original, buffer);
-	}
+  char* ch;
+  char buffer[1024];
+  int offset = 0;
+  while ((ch = strstr(original + offset, search))) {
+    strncpy(buffer, original, ch - original);
+    buffer[ch - original] = 0;
+    sprintf(buffer + (ch - original), "%s%s", replacer, ch + strlen(search));
+    original[0] = 0;
+    strcpy(original, buffer);
+    offset = ch - original + strlen(replacer);
+  }
 }
 
 // Replaces all terms in a string with another term, case insensitive
 void replace_ignorecase(char* original, char* search, char* replacer) {
-	char* ch;
-	char buffer[1024];
+  char* ch;
+  char buffer[1024];
+  int offset = 0;
 #ifdef _WIN32
-	#define strcasestr(o, s) strstr(o, s)
+  #define strcasestr(o, s) strstr(o, s)
 #endif
-	while ((ch = strcasestr(original, search))) {
-		strncpy(buffer, original, ch - original);
-		buffer[ch - original] = 0;
-		sprintf(buffer + (ch - original), "%s%s", replacer, ch + strlen(search));
-		original[0] = 0;
-		strcpy(original, buffer);
-	}
+  while ((ch = strcasestr(original + offset, search))) {
+    strncpy(buffer, original, ch - original);
+    buffer[ch - original] = 0;
+    sprintf(buffer + (ch - original), "%s%s", replacer, ch + strlen(search));
+    original[0] = 0;
+    strcpy(original, buffer);
+    offset = ch - original + strlen(replacer);
+  }
 }
 
 #ifdef _WIN32
 // windows sucks and hasn't a strstep, so I copied one from https://stackoverflow.com/questions/8512958/is-there-a-windows-variant-of-strsep-function
 char* strsep(char** stringp, const char* delim) {
-	char* start = *stringp;
-	char* p;
-	p = (start != NULL) ? strpbrk(start, delim) : NULL;
-	if (p == NULL)
-		*stringp = NULL;
-	else {
-		*p			 = '\0';
-		*stringp = p + 1;
-	}
-	return start;
+  char* start = *stringp;
+  char* p;
+  p = (start != NULL) ? strpbrk(start, delim) : NULL;
+  if (p == NULL)
+    *stringp = NULL;
+  else {
+    *p       = '\0';
+    *stringp = p + 1;
+  }
+  return start;
 }
 #endif
 
 // uwufies distro name
 void uwu_name(struct info* user_info) {
 #define STRING_TO_UWU(original, uwufied) \
-	if (strcmp(user_info->os_name, original) == 0) sprintf(user_info->os_name, "%s", uwufied)
-	// linux
-	STRING_TO_UWU("alpine", "Nyalpine");
-	else STRING_TO_UWU("amogos", "AmogOwOS");
-	else STRING_TO_UWU("android", "Nyandroid");
-	else STRING_TO_UWU("arch", "Nyarch Linuwu");
-	else STRING_TO_UWU("arcolinux", "ArcOwO Linuwu");
-	else STRING_TO_UWU("artix", "Nyartix Linuwu");
-	else STRING_TO_UWU("debian", "Debinyan");
-	else STRING_TO_UWU("devuan", "Devunyan");
-	else STRING_TO_UWU("deepin", "Dewepyn");
-	else STRING_TO_UWU("endeavouros", "endeavOwO");
-	else STRING_TO_UWU("EndeavourOS", "endeavOwO");
-	else STRING_TO_UWU("fedora", "Fedowa");
-	else STRING_TO_UWU("femboyos", "FemboyOWOS");
-	else STRING_TO_UWU("gentoo", "GentOwO");
-	else STRING_TO_UWU("gnu", "gnUwU");
-	else STRING_TO_UWU("guix", "gnUwU gUwUix");
-	else STRING_TO_UWU("linuxmint", "LinUWU Miwint");
-	else STRING_TO_UWU("manjaro", "Myanjawo");
-	else STRING_TO_UWU("manjaro-arm", "Myanjawo AWM");
-	else STRING_TO_UWU("neon", "KDE NeOwOn");
-	else STRING_TO_UWU("nixos", "nixOwOs");
-	else STRING_TO_UWU("opensuse-leap", "OwOpenSUSE Leap");
-	else STRING_TO_UWU("opensuse-tumbleweed", "OwOpenSUSE Tumbleweed");
-	else STRING_TO_UWU("pop", "PopOwOS");
-	else STRING_TO_UWU("raspbian", "RaspNyan");
-	else STRING_TO_UWU("rocky", "Wocky Linuwu");
-	else STRING_TO_UWU("slackware", "Swackwawe");
-	else STRING_TO_UWU("solus", "sOwOlus");
-	else STRING_TO_UWU("ubuntu", "Uwuntu");
-	else STRING_TO_UWU("void", "OwOid");
-	else STRING_TO_UWU("xerolinux", "xuwulinux");
-
-	// BSD
-	else STRING_TO_UWU("freebsd", "FweeBSD");
-	else STRING_TO_UWU("openbsd", "OwOpenBSD");
-
-	// Apple family
-	else STRING_TO_UWU("macos", "macOwOS");
-	else STRING_TO_UWU("ios", "iOwOS");
+  if (strcmp(user_info->os_name, original) == 0) sprintf(user_info->os_name, "%s", uwufied)
+  // linux
+  STRING_TO_UWU("alpine", "Nyalpine");
+  else STRING_TO_UWU("amogos", "AmogOwOS");
+  else STRING_TO_UWU("android", "Nyandroid");
+  else STRING_TO_UWU("arch", "Nyarch Linuwu");
+  else STRING_TO_UWU("arcolinux", "ArcOwO Linuwu");
+  else STRING_TO_UWU("artix", "Nyartix Linuwu");
+  else STRING_TO_UWU("debian", "Debinyan");
+  else STRING_TO_UWU("devuan", "Devunyan");
+  else STRING_TO_UWU("deepin", "Dewepyn");
+  else STRING_TO_UWU("endeavouros", "endeavOwO");
+  else STRING_TO_UWU("EndeavourOS", "endeavOwO");
+  else STRING_TO_UWU("fedora", "Fedowa");
+  else STRING_TO_UWU("femboyos", "FemboyOWOS");
+  else STRING_TO_UWU("gentoo", "GentOwO");
+  else STRING_TO_UWU("gnu", "gnUwU");
+  else STRING_TO_UWU("guix", "gnUwU gUwUix");
+  else STRING_TO_UWU("linuxmint", "LinUWU Miwint");
+  else STRING_TO_UWU("manjaro", "Myanjawo");
+  else STRING_TO_UWU("manjaro-arm", "Myanjawo AWM");
+  else STRING_TO_UWU("neon", "KDE NeOwOn");
+  else STRING_TO_UWU("nixos", "nixOwOs");
+  else STRING_TO_UWU("opensuse-leap", "OwOpenSUSE Leap");
+  else STRING_TO_UWU("opensuse-tumbleweed", "OwOpenSUSE Tumbleweed");
+  else STRING_TO_UWU("pop", "PopOwOS");
+  else STRING_TO_UWU("raspbian", "RaspNyan");
+  else STRING_TO_UWU("rocky", "Wocky Linuwu");
+  else STRING_TO_UWU("slackware", "Swackwawe");
+  else STRING_TO_UWU("solus", "sOwOlus");
+  else STRING_TO_UWU("ubuntu", "Uwuntu");
+  else STRING_TO_UWU("void", "OwOid");
+  else STRING_TO_UWU("xerolinux", "xuwulinux");
+  else STRING_TO_UWU("menhera", "MenheraOS");
+
+  // BSD
+  else STRING_TO_UWU("freebsd", "FweeBSD");
+  else STRING_TO_UWU("openbsd", "OwOpenBSD");
+
+  // Apple family
+  else STRING_TO_UWU("macos", "macOwOS");
+  else STRING_TO_UWU("ios", "iOwOS");
 
-	// Windows
-	else STRING_TO_UWU("windows", "WinyandOwOws");
+  // Windows
+  else STRING_TO_UWU("windows", "WinyandOwOws");
 
-	else sprintf(user_info->os_name, "%s", "unknown");
+  else sprintf(user_info->os_name, "%s", "unknown");
 #undef STRING_TO_UWU
 }
 
 // uwufies kernel name
 void uwu_kernel(char* kernel) {
 #define KERNEL_TO_UWU(str, original, uwufied) \
-	if (strcmp(str, original) == 0) sprintf(str, "%s", uwufied)
+  if (strcmp(str, original) == 0) sprintf(str, "%s", uwufied)
 
-	LOG_I("uwufing kernel");
+  LOG_I("uwufing kernel");
 
-	char* temp_kernel = kernel;
-	char* token;
-	char splitted[16][128] = {};
-
-	int count = 0;
-	while ((token = strsep(&temp_kernel, " "))) { // split kernel name
-		strcpy(splitted[count], token);
-		count++;
-	}
-	strcpy(kernel, "");
-	for (int i = 0; i < 16; i++) {
-		// replace kernel name with uwufied version
-		KERNEL_TO_UWU(splitted[i], "Linux", "Linuwu");
-		else KERNEL_TO_UWU(splitted[i], "linux", "linuwu");
-		else KERNEL_TO_UWU(splitted[i], "alpine", "Nyalpine");
-		else KERNEL_TO_UWU(splitted[i], "amogos", "AmogOwOS");
-		else KERNEL_TO_UWU(splitted[i], "android", "Nyandroid");
-		else KERNEL_TO_UWU(splitted[i], "arch", "Nyarch Linuwu");
-		else KERNEL_TO_UWU(splitted[i], "artix", "Nyartix Linuwu");
-		else KERNEL_TO_UWU(splitted[i], "debian", "Debinyan");
-		else KERNEL_TO_UWU(splitted[i], "deepin", "Dewepyn");
-		else KERNEL_TO_UWU(splitted[i], "endeavouros", "endeavOwO");
-		else KERNEL_TO_UWU(splitted[i], "EndeavourOS", "endeavOwO");
-		else KERNEL_TO_UWU(splitted[i], "fedora", "Fedowa");
-		else KERNEL_TO_UWU(splitted[i], "femboyos", "FemboyOWOS");
-		else KERNEL_TO_UWU(splitted[i], "gentoo", "GentOwO");
-		else KERNEL_TO_UWU(splitted[i], "gnu", "gnUwU");
-		else KERNEL_TO_UWU(splitted[i], "guix", "gnUwU gUwUix");
-		else KERNEL_TO_UWU(splitted[i], "linuxmint", "LinUWU Miwint");
-		else KERNEL_TO_UWU(splitted[i], "manjaro", "Myanjawo");
-		else KERNEL_TO_UWU(splitted[i], "manjaro-arm", "Myanjawo AWM");
-		else KERNEL_TO_UWU(splitted[i], "neon", "KDE NeOwOn");
-		else KERNEL_TO_UWU(splitted[i], "nixos", "nixOwOs");
-		else KERNEL_TO_UWU(splitted[i], "opensuse-leap", "OwOpenSUSE Leap");
-		else KERNEL_TO_UWU(splitted[i], "opensuse-tumbleweed", "OwOpenSUSE Tumbleweed");
-		else KERNEL_TO_UWU(splitted[i], "pop", "PopOwOS");
-		else KERNEL_TO_UWU(splitted[i], "raspbian", "RaspNyan");
-		else KERNEL_TO_UWU(splitted[i], "rocky", "Wocky Linuwu");
-		else KERNEL_TO_UWU(splitted[i], "slackware", "Swackwawe");
-		else KERNEL_TO_UWU(splitted[i], "solus", "sOwOlus");
-		else KERNEL_TO_UWU(splitted[i], "ubuntu", "Uwuntu");
-		else KERNEL_TO_UWU(splitted[i], "void", "OwOid");
-		else KERNEL_TO_UWU(splitted[i], "xerolinux", "xuwulinux");
-
-		// BSD
-		else KERNEL_TO_UWU(splitted[i], "freebsd", "FweeBSD");
-		else KERNEL_TO_UWU(splitted[i], "openbsd", "OwOpenBSD");
-
-		// Apple family
-		else KERNEL_TO_UWU(splitted[i], "macos", "macOwOS");
-		else KERNEL_TO_UWU(splitted[i], "ios", "iOwOS");
-
-		// Windows
-		else KERNEL_TO_UWU(splitted[i], "windows", "WinyandOwOws");
-
-		if (i != 0) strcat(kernel, " ");
-		strcat(kernel, splitted[i]);
-	}
+  char* temp_kernel = kernel;
+  char* token;
+  char splitted[16][128] = {};
+
+  int count = 0;
+  while ((token = strsep(&temp_kernel, " "))) { // split kernel name
+    strcpy(splitted[count], token);
+    count++;
+  }
+  strcpy(kernel, "");
+  for (int i = 0; i < 16; i++) {
+    // replace kernel name with uwufied version
+    KERNEL_TO_UWU(splitted[i], "Linux", "Linuwu");
+    else KERNEL_TO_UWU(splitted[i], "linux", "linuwu");
+    else KERNEL_TO_UWU(splitted[i], "alpine", "Nyalpine");
+    else KERNEL_TO_UWU(splitted[i], "amogos", "AmogOwOS");
+    else KERNEL_TO_UWU(splitted[i], "android", "Nyandroid");
+    else KERNEL_TO_UWU(splitted[i], "arch", "Nyarch Linuwu");
+    else KERNEL_TO_UWU(splitted[i], "artix", "Nyartix Linuwu");
+    else KERNEL_TO_UWU(splitted[i], "debian", "Debinyan");
+    else KERNEL_TO_UWU(splitted[i], "deepin", "Dewepyn");
+    else KERNEL_TO_UWU(splitted[i], "endeavouros", "endeavOwO");
+    else KERNEL_TO_UWU(splitted[i], "EndeavourOS", "endeavOwO");
+    else KERNEL_TO_UWU(splitted[i], "fedora", "Fedowa");
+    else KERNEL_TO_UWU(splitted[i], "femboyos", "FemboyOWOS");
+    else KERNEL_TO_UWU(splitted[i], "gentoo", "GentOwO");
+    else KERNEL_TO_UWU(splitted[i], "gnu", "gnUwU");
+    else KERNEL_TO_UWU(splitted[i], "guix", "gnUwU gUwUix");
+    else KERNEL_TO_UWU(splitted[i], "linuxmint", "LinUWU Miwint");
+    else KERNEL_TO_UWU(splitted[i], "manjaro", "Myanjawo");
+    else KERNEL_TO_UWU(splitted[i], "manjaro-arm", "Myanjawo AWM");
+    else KERNEL_TO_UWU(splitted[i], "neon", "KDE NeOwOn");
+    else KERNEL_TO_UWU(splitted[i], "nixos", "nixOwOs");
+    else KERNEL_TO_UWU(splitted[i], "opensuse-leap", "OwOpenSUSE Leap");
+    else KERNEL_TO_UWU(splitted[i], "opensuse-tumbleweed", "OwOpenSUSE Tumbleweed");
+    else KERNEL_TO_UWU(splitted[i], "pop", "PopOwOS");
+    else KERNEL_TO_UWU(splitted[i], "raspbian", "RaspNyan");
+    else KERNEL_TO_UWU(splitted[i], "rocky", "Wocky Linuwu");
+    else KERNEL_TO_UWU(splitted[i], "slackware", "Swackwawe");
+    else KERNEL_TO_UWU(splitted[i], "solus", "sOwOlus");
+    else KERNEL_TO_UWU(splitted[i], "ubuntu", "Uwuntu");
+    else KERNEL_TO_UWU(splitted[i], "void", "OwOid");
+    else KERNEL_TO_UWU(splitted[i], "xerolinux", "xuwulinux");
+
+    // BSD
+    else KERNEL_TO_UWU(splitted[i], "freebsd", "FweeBSD");
+    else KERNEL_TO_UWU(splitted[i], "openbsd", "OwOpenBSD");
+
+    // Apple family
+    else KERNEL_TO_UWU(splitted[i], "macos", "macOwOS");
+    else KERNEL_TO_UWU(splitted[i], "ios", "iOwOS");
+
+    // Windows
+    else KERNEL_TO_UWU(splitted[i], "windows", "WinyandOwOws");
+
+    if (i != 0) strcat(kernel, " ");
+    strcat(kernel, splitted[i]);
+  }
 #undef KERNEL_TO_UWU
-	LOG_V(kernel);
+  LOG_V(kernel);
 }
 
 // uwufies hardware names
 void uwu_hw(char* hwname) {
-	LOG_I("uwufing hardware")
+  LOG_I("uwufing hardware")
 #define HW_TO_UWU(original, uwuified) replace_ignorecase(hwname, original, uwuified);
-	HW_TO_UWU("lenovo", "LenOwO")
-	HW_TO_UWU("cpu", "CC\bPUwU"); // for some reasons this caused a segfault, using a \b (backspace) char fixes it
-	HW_TO_UWU("core", "Cowe");
-	HW_TO_UWU("gpu", "GG\bPUwU")
-	HW_TO_UWU("graphics", "Gwaphics")
-	HW_TO_UWU("corporation", "COwOpowation")
-	HW_TO_UWU("nvidia", "NyaVIDIA")
-	HW_TO_UWU("mobile", "Mwobile")
-	HW_TO_UWU("intel", "Inteww")
-	HW_TO_UWU("radeon", "Radenyan")
-	HW_TO_UWU("geforce", "GeFOwOce")
-	HW_TO_UWU("raspberry", "Nyasberry")
-	HW_TO_UWU("broadcom", "Bwoadcom")
-	HW_TO_UWU("motorola", "MotOwOwa")
-	HW_TO_UWU("proliant", "ProLinyant")
-	HW_TO_UWU("poweredge", "POwOwEdge")
-	HW_TO_UWU("apple", "Nyaa\bpple")
-	HW_TO_UWU("electronic", "ElectrOwOnic")
+  HW_TO_UWU("lenovo", "LenOwO")
+  HW_TO_UWU("cpu", "CPUwU");
+  HW_TO_UWU("core", "Cowe");
+  HW_TO_UWU("gpu", "GPUwU")
+  HW_TO_UWU("graphics", "Gwaphics")
+  HW_TO_UWU("corporation", "COwOpowation")
+  HW_TO_UWU("nvidia", "NyaVIDIA")
+  HW_TO_UWU("mobile", "Mwobile")
+  HW_TO_UWU("intel", "Inteww")
+  HW_TO_UWU("celeron", "Celewon")
+  HW_TO_UWU("radeon", "Radenyan")
+  HW_TO_UWU("geforce", "GeFOwOce")
+  HW_TO_UWU("raspberry", "Nyasberry")
+  HW_TO_UWU("broadcom", "Bwoadcom")
+  HW_TO_UWU("motorola", "MotOwOwa")
+  HW_TO_UWU("proliant", "ProLinyant")
+  HW_TO_UWU("poweredge", "POwOwEdge")
+  HW_TO_UWU("apple", "Nyapple")
+  HW_TO_UWU("electronic", "ElectrOwOnic")
+  HW_TO_UWU("processor", "Pwocessow")
+  HW_TO_UWU("microsoft", "MicOwOsoft")
+  HW_TO_UWU("ryzen", "Wyzen")
+  HW_TO_UWU("advanced", "Adwanced")
+  HW_TO_UWU("micro", "Micwo")
+  HW_TO_UWU("devices", "Dewices")
+  HW_TO_UWU("inc.", "Nyanc.")
+  HW_TO_UWU("lucienne", "Lucienyan")
+  HW_TO_UWU("tuxedo", "TUWUXEDO")
+  HW_TO_UWU("aura", "Uwura")
 #undef HW_TO_UWU
 }
 
+// uwufies package manager names
+void uwu_pkgman(char* pkgman_name) {
+  LOG_I("uwufing package managers")
+#define PKGMAN_TO_UWU(original, uwuified) replace_ignorecase(pkgman_name, original, uwuified);
+  // these package managers do not have edits yet:
+  // apk, apt, guix, nix, pkg, xbps
+  PKGMAN_TO_UWU("brew-cask", "bwew-cawsk");
+  PKGMAN_TO_UWU("brew-cellar", "bwew-cewwaw");
+  PKGMAN_TO_UWU("emerge", "emewge");
+  PKGMAN_TO_UWU("flatpak", "fwatpakkies");
+  PKGMAN_TO_UWU("pacman", "pacnyan");
+  PKGMAN_TO_UWU("port", "powt");
+  PKGMAN_TO_UWU("snap", "snyap");
+#undef PKGMAN_TO_UWU
+}
+
 // uwufies everything
 void uwufy_all(struct info* user_info) {
-	LOG_I("uwufing everything");
-	if (strcmp(user_info->os_name, "windows"))
-		MOVE_CURSOR = "\033[21C"; // to print windows logo on not windows systems
-	uwu_kernel(user_info->kernel);
-	for (int i = 0; user_info->gpu_model[i][0]; i++) uwu_hw(user_info->gpu_model[i]);
-	uwu_hw(user_info->cpu_model);
-	LOG_V(user_info->cpu_model);
-	uwu_hw(user_info->model);
-	LOG_V(user_info->model);
+  LOG_I("uwufing everything");
+  if (strcmp(user_info->os_name, "windows"))
+    MOVE_CURSOR = "\033[21C"; // to print windows logo on not windows systems
+  uwu_kernel(user_info->kernel);
+  for (int i = 0; user_info->gpu_model[i][0]; i++) uwu_hw(user_info->gpu_model[i]);
+  uwu_hw(user_info->cpu_model);
+  LOG_V(user_info->cpu_model);
+  uwu_hw(user_info->model);
+  LOG_V(user_info->model);
+  uwu_pkgman(user_info->pkgman_name);
+  LOG_V(user_info->pkgman_name);
 }
 
 // prints all the collected info and returns the number of printed lines
 int print_info(struct configuration* config_flags, struct info* user_info) {
-	int line_count = 0;
+  int line_count = 0;
 #ifdef _WIN32
-	// prints without overflowing the terminal width
-	#define responsively_printf(buf, format, ...)     \
-		{                                               \
-			sprintf(buf, format, __VA_ARGS__);            \
-			printf("%.*s\n", user_info->ws_col - 4, buf); \
-			line_count++;                                 \
-		}
+  // prints without overflowing the terminal width
+  #define responsively_printf(buf, format, ...)     \
+    {                                               \
+      sprintf(buf, format, __VA_ARGS__);            \
+      printf("%.*s\n", user_info->ws_col - 4, buf); \
+      line_count++;                                 \
+    }
 #else // _WIN32
-	// prints without overflowing the terminal width
-	#define responsively_printf(buf, format, ...)         \
-		{                                                   \
-			sprintf(buf, format, __VA_ARGS__);                \
-			printf("%.*s\n", user_info->win.ws_col - 4, buf); \
-			line_count++;                                     \
-		}
-#endif									// _WIN32
-	char print_buf[1024]; // for responsively print
-
-	// print collected info - from host to cpu info
-	if (config_flags->show.user)
-		responsively_printf(print_buf, "%s%s%s%s@%s", MOVE_CURSOR, NORMAL, BOLD, user_info->user, user_info->host);
-	uwu_name(user_info);
-	if (config_flags->show.os)
-		responsively_printf(print_buf, "%s%s%sOWOS     %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->os_name);
-	if (config_flags->show.model)
-		responsively_printf(print_buf, "%s%s%sMOWODEL  %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->model);
-	if (config_flags->show.kernel)
-		responsively_printf(print_buf, "%s%s%sKEWNEL   %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->kernel);
-	if (config_flags->show.cpu)
-		responsively_printf(print_buf, "%s%s%sCPUWU    %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->cpu_model);
-
-	if (config_flags->show_gpu[0] == -2) { // print all gpu models
-		for (int i = 0; i < 256 && user_info->gpu_model[i][0]; i++)
-			responsively_printf(print_buf, "%s%s%sGPUWU    %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->gpu_model[i]);
-	} else if (config_flags->show_gpu[0] != -3) { // print only the configured gpu models
-		for (int i = 0; i < 256; i++) {
-			if (config_flags->show_gpu[i] >= 0)
-				if (user_info->gpu_model[config_flags->show_gpu[i]][0])
-					responsively_printf(print_buf, "%s%s%sGPUWU    %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->gpu_model[config_flags->show_gpu[i]]);
-		}
-	}
-
-	if (config_flags->show.ram) // print ram
-		responsively_printf(print_buf, "%s%s%sMEMOWY   %s%i MiB/%i MiB", MOVE_CURSOR, NORMAL, BOLD, NORMAL, (user_info->ram_used), user_info->ram_total);
-	if (config_flags->show.resolution) // print resolution
-		if (user_info->screen_width != 0 || user_info->screen_height != 0)
-			responsively_printf(print_buf, "%s%s%sWESOWUTION%s  %dx%d", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->screen_width, user_info->screen_height);
-	if (config_flags->show.shell) // print shell name
-		responsively_printf(print_buf, "%s%s%sSHEWW    %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->shell);
-	if (config_flags->show.pkgs) // print pkgs
-		responsively_printf(print_buf, "%s%s%sPKGS     %s%d: %s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->pkgs, user_info->pkgman_name);
-	// #endif
-	if (config_flags->show.uptime) {
-		switch (user_info->uptime) { // formatting the uptime which is store in seconds
-		case 0 ... 3599:
-			responsively_printf(print_buf, "%s%s%sUWUPTIME %s%lim", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->uptime / 60 % 60);
-			break;
-		case 3600 ... 86399:
-			responsively_printf(print_buf, "%s%s%sUWUPTIME %s%lih, %lim", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->uptime / 3600, user_info->uptime / 60 % 60);
-			break;
-		default:
-			responsively_printf(print_buf, "%s%s%sUWUPTIME %s%lid, %lih, %lim", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->uptime / 86400, user_info->uptime / 3600 % 24, user_info->uptime / 60 % 60);
-		}
-	}
-	// clang-format off
+  // prints without overflowing the terminal width
+  #define responsively_printf(buf, format, ...)         \
+    {                                                   \
+      sprintf(buf, format, __VA_ARGS__);                \
+      printf("%.*s\n", user_info->win.ws_col - 4, buf); \
+      line_count++;                                     \
+    }
+#endif                  // _WIN32
+  char print_buf[1024]; // for responsively print
+
+  // print collected info - from host to cpu info
+  if (config_flags->show.user)
+    responsively_printf(print_buf, "%s%s%s%s@%s", MOVE_CURSOR, NORMAL, BOLD, user_info->user, user_info->host);
+  uwu_name(user_info);
+  if (config_flags->show.os)
+    responsively_printf(print_buf, "%s%s%sOWOS     %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->os_name);
+  if (config_flags->show.model)
+    responsively_printf(print_buf, "%s%s%sMOWODEL  %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->model);
+  if (config_flags->show.kernel)
+    responsively_printf(print_buf, "%s%s%sKEWNEL   %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->kernel);
+  if (config_flags->show.cpu)
+    responsively_printf(print_buf, "%s%s%sCPUWU    %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->cpu_model);
+
+  for (int i = 0; i < 256; i++) {
+    if (config_flags->show_gpu[i])
+      if (user_info->gpu_model[i][0])
+        responsively_printf(print_buf, "%s%s%sGPUWU    %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->gpu_model[i]);
+  }
+
+  if (config_flags->show.ram) // print ram
+    responsively_printf(print_buf, "%s%s%sMEMOWY   %s%i MiB/%i MiB", MOVE_CURSOR, NORMAL, BOLD, NORMAL, (user_info->ram_used), user_info->ram_total);
+  if (config_flags->show.resolution) // print resolution
+    if (user_info->screen_width != 0 || user_info->screen_height != 0)
+      responsively_printf(print_buf, "%s%s%sWESOWUTION%s  %dx%d", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->screen_width, user_info->screen_height);
+  if (config_flags->show.shell) // print shell name
+    responsively_printf(print_buf, "%s%s%sSHEWW    %s%s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->shell);
+  if (config_flags->show.pkgs) // print pkgs
+    responsively_printf(print_buf, "%s%s%sPKGS     %s%d: %s", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->pkgs, user_info->pkgman_name);
+  // #endif
+  if (config_flags->show.uptime) {
+    switch (user_info->uptime) { // formatting the uptime which is store in seconds
+    case 0 ... 3599:
+      responsively_printf(print_buf, "%s%s%sUWUPTIME %s%lim", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->uptime / 60 % 60);
+      break;
+    case 3600 ... 86399:
+      responsively_printf(print_buf, "%s%s%sUWUPTIME %s%lih, %lim", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->uptime / 3600, user_info->uptime / 60 % 60);
+      break;
+    default:
+      responsively_printf(print_buf, "%s%s%sUWUPTIME %s%lid, %lih, %lim", MOVE_CURSOR, NORMAL, BOLD, NORMAL, user_info->uptime / 86400, user_info->uptime / 3600 % 24, user_info->uptime / 60 % 60);
+    }
+  }
+  // clang-format off
 	if (config_flags->show_colors)
 		printf("%s"	BOLD BLACK BLOCK_CHAR BLOCK_CHAR RED BLOCK_CHAR
 								BLOCK_CHAR GREEN BLOCK_CHAR BLOCK_CHAR YELLOW
 								BLOCK_CHAR BLOCK_CHAR BLUE BLOCK_CHAR BLOCK_CHAR
 								MAGENTA BLOCK_CHAR BLOCK_CHAR CYAN BLOCK_CHAR
 								BLOCK_CHAR WHITE BLOCK_CHAR BLOCK_CHAR NORMAL "\n", MOVE_CURSOR);
-	// clang-format on
-	return line_count;
+  // clang-format on
+  return line_count;
 }
 
 // writes cache to cache file
 void write_cache(struct info* user_info) {
-	LOG_I("writing cache");
-	char cache_file[512];
-	sprintf(cache_file, "%s/.cache/uwufetch.cache", getenv("HOME")); // default cache file location
-	LOG_V(cache_file);
-	FILE* cache_fp = fopen(cache_file, "w");
-	if (cache_fp == NULL) {
-		LOG_E("Failed to write to %s!", cache_file);
-		return;
-	}
-	// writing all info to the cache file
-	fprintf( // writing most of the values to config file
-			cache_fp,
-			"user=%s\nhost=%s\nversion_name=%s\nhost_model=%s\nkernel=%s\ncpu=%"
-			"s\nscreen_width=%d\nscreen_height=%d\nshell=%s\npkgs=%d\npkgman_name=%"
-			"s\n",
-			user_info->user, user_info->host, user_info->os_name, user_info->model, user_info->kernel,
-			user_info->cpu_model, user_info->screen_width, user_info->screen_height, user_info->shell,
-			user_info->pkgs, user_info->pkgman_name);
+  LOG_I("writing cache");
+  char cache_file[512];
+  sprintf(cache_file, "%s/.cache/uwufetch.cache", getenv("HOME")); // default cache file location
+  LOG_V(cache_file);
+  FILE* cache_fp = fopen(cache_file, "w");
+  if (cache_fp == NULL) {
+    LOG_E("Failed to write to %s!", cache_file);
+    return;
+  }
+  // writing all info to the cache file
+  fprintf( // writing most of the values to config file
+      cache_fp,
+      "user=%s\nhost=%s\nversion_name=%s\nhost_model=%s\nkernel=%s\ncpu=%"
+      "s\nscreen_width=%d\nscreen_height=%d\nshell=%s\npkgs=%d\npkgman_name=%"
+      "s\n",
+      user_info->user, user_info->host, user_info->os_name, user_info->model, user_info->kernel,
+      user_info->cpu_model, user_info->screen_width, user_info->screen_height, user_info->shell,
+      user_info->pkgs, user_info->pkgman_name);
 
-	for (int i = 0; user_info->gpu_model[i][0]; i++) // writing gpu names to file
-		fprintf(cache_fp, "gpu=%s\n", user_info->gpu_model[i]);
+  for (int i = 0; user_info->gpu_model[i][0]; i++) // writing gpu names to file
+    fprintf(cache_fp, "gpu=%s\n", user_info->gpu_model[i]);
 
-	fclose(cache_fp);
-	return;
+  fclose(cache_fp);
+  return;
 }
 
 // reads cache file if it exists
 int read_cache(struct info* user_info) {
-	LOG_I("reading cache");
-	char cache_file[512];
-	sprintf(cache_file, "%s/.cache/uwufetch.cache", getenv("HOME")); // cache file location
-	LOG_V(cache_file);
-	FILE* cache_fp = fopen(cache_file, "r");
-	if (cache_fp == NULL) return 0;
-	char buffer[256];																	// line buffer
-	int gpuc = 0;																			// gpu counter
-	while (fgets(buffer, sizeof(buffer), cache_fp)) { // reading the file
-		sscanf(buffer, "user=%99[^\n]", user_info->user);
-		sscanf(buffer, "host=%99[^\n]", user_info->host);
-		sscanf(buffer, "version_name=%99[^\n]", user_info->os_name);
-		sscanf(buffer, "host_model=%99[^\n]", user_info->model);
-		sscanf(buffer, "kernel=%99[^\n]", user_info->kernel);
-		sscanf(buffer, "cpu=%99[^\n]", user_info->cpu_model);
-		if (sscanf(buffer, "gpu=%99[^\n]", user_info->gpu_model[gpuc]) != 0) gpuc++;
-		sscanf(buffer, "screen_width=%i", &user_info->screen_width);
-		sscanf(buffer, "screen_height=%i", &user_info->screen_height);
-		sscanf(buffer, "shell=%99[^\n]", user_info->shell);
-		sscanf(buffer, "pkgs=%i", &user_info->pkgs);
-		sscanf(buffer, "pkgman_name=%99[^\n]", user_info->pkgman_name);
-	}
-	LOG_V(user_info->user);
-	LOG_V(user_info->host);
-	LOG_V(user_info->os_name);
-	LOG_V(user_info->model);
-	LOG_V(user_info->kernel);
-	LOG_V(user_info->cpu_model);
-	LOG_V(user_info->gpu_model[gpuc]);
-	LOG_V(user_info->screen_width);
-	LOG_V(user_info->screen_height);
-	LOG_V(user_info->shell);
-	LOG_V(user_info->pkgs);
-	LOG_V(user_info->pkgman_name);
-	fclose(cache_fp);
-	return 1;
+  LOG_I("reading cache");
+  char cache_file[512];
+  sprintf(cache_file, "%s/.cache/uwufetch.cache", getenv("HOME")); // cache file location
+  LOG_V(cache_file);
+  FILE* cache_fp = fopen(cache_file, "r");
+  if (cache_fp == NULL) return 0;
+  char buffer[256];                                 // line buffer
+  int gpuc = 0;                                     // gpu counter
+  while (fgets(buffer, sizeof(buffer), cache_fp)) { // reading the file
+    sscanf(buffer, "user=%99[^\n]", user_info->user);
+    sscanf(buffer, "host=%99[^\n]", user_info->host);
+    sscanf(buffer, "version_name=%99[^\n]", user_info->os_name);
+    sscanf(buffer, "host_model=%99[^\n]", user_info->model);
+    sscanf(buffer, "kernel=%99[^\n]", user_info->kernel);
+    sscanf(buffer, "cpu=%99[^\n]", user_info->cpu_model);
+    if (sscanf(buffer, "gpu=%99[^\n]", user_info->gpu_model[gpuc]) != 0) gpuc++;
+    sscanf(buffer, "screen_width=%i", &user_info->screen_width);
+    sscanf(buffer, "screen_height=%i", &user_info->screen_height);
+    sscanf(buffer, "shell=%99[^\n]", user_info->shell);
+    sscanf(buffer, "pkgs=%i", &user_info->pkgs);
+    sscanf(buffer, "pkgman_name=%99[^\n]", user_info->pkgman_name);
+  }
+  LOG_V(user_info->user);
+  LOG_V(user_info->host);
+  LOG_V(user_info->os_name);
+  LOG_V(user_info->model);
+  LOG_V(user_info->kernel);
+  LOG_V(user_info->cpu_model);
+  LOG_V(user_info->gpu_model[gpuc]);
+  LOG_V(user_info->screen_width);
+  LOG_V(user_info->screen_height);
+  LOG_V(user_info->shell);
+  LOG_V(user_info->pkgs);
+  LOG_V(user_info->pkgman_name);
+  fclose(cache_fp);
+  return 1;
 }
 
 // prints logo (as ascii art) of the given system.
 int print_ascii(struct info* user_info) {
-	FILE* file;
-	char ascii_file[1024];
-	// First tries to get ascii art file from local directory. Useful for debugging
-	sprintf(ascii_file, "./res/ascii/%s.txt", user_info->os_name);
-	LOG_V(ascii_file);
-	file = fopen(ascii_file, "r");
-	if (!file) { // if the file does not exist in the local directory, open it from the installation directory
-		if (strcmp(user_info->os_name, "android") == 0)
-			sprintf(ascii_file, "/data/data/com.termux/files/usr/lib/uwufetch/ascii/%s.txt", user_info->os_name);
-		else if (strcmp(user_info->os_name, "macos") == 0)
-			sprintf(ascii_file, "/usr/local/lib/uwufetch/ascii/%s.txt", user_info->os_name);
-		else
-			sprintf(ascii_file, "/usr/lib/uwufetch/ascii/%s.txt", user_info->os_name);
-		LOG_V(ascii_file);
-
-		file = fopen(ascii_file, "r");
-		if (!file) {
-			// Prevent infinite loops
-			if (strcmp(user_info->os_name, "unknown") == 0) {
-				LOG_E("No\nunknown\nascii\nfile\n\n\n\n");
-				return 7;
-			}
-			sprintf(user_info->os_name, "unknown"); // current os is not supported
-			LOG_V(user_info->os_name);
-			return print_ascii(user_info);
-		}
-	}
-	char buffer[256]; // line buffer
-	int line_count = 1;
-	printf("\n");
-	while (fgets(buffer, 256, file)) { // replacing color placecholders
-		replace(buffer, "{NORMAL}", NORMAL);
-		replace(buffer, "{BOLD}", BOLD);
-		replace(buffer, "{BLACK}", BLACK);
-		replace(buffer, "{RED}", RED);
-		replace(buffer, "{GREEN}", GREEN);
-		replace(buffer, "{SPRING_GREEN}", SPRING_GREEN);
-		replace(buffer, "{YELLOW}", YELLOW);
-		replace(buffer, "{BLUE}", BLUE);
-		replace(buffer, "{MAGENTA}", MAGENTA);
-		replace(buffer, "{CYAN}", CYAN);
-		replace(buffer, "{WHITE}", WHITE);
-		replace(buffer, "{PINK}", PINK);
-		replace(buffer, "{LPINK}", LPINK);
-		replace(buffer, "{BLOCK}", BLOCK_CHAR);
-		replace(buffer, "{BLOCK_VERTICAL}", BLOCK_CHAR);
-		replace(buffer, "{BACKGROUND_GREEN}", "\e[0;42m");
-		replace(buffer, "{BACKGROUND_RED}", "\e[0;41m");
-		replace(buffer, "{BACKGROUND_WHITE}", "\e[0;47m");
-		printf("%s", buffer); // print the line after setting the color
-		line_count++;
-	}
-	// Always set color to NORMAL, so there's no need to do this in every ascii file.
-	printf(NORMAL);
-	fclose(file);
-	return line_count;
+  FILE* file;
+  char ascii_file[1024];
+  // First tries to get ascii art file from local directory. Useful for debugging
+  sprintf(ascii_file, "./res/ascii/%s.txt", user_info->os_name);
+  LOG_V(ascii_file);
+  file = fopen(ascii_file, "r");
+  if (!file) { // if the file does not exist in the local directory, open it from the installation directory
+    if (strcmp(user_info->os_name, "android") == 0)
+      sprintf(ascii_file, "/data/data/com.termux/files/usr/lib/uwufetch/ascii/%s.txt", user_info->os_name);
+    else if (strcmp(user_info->os_name, "macos") == 0)
+      sprintf(ascii_file, "/usr/local/lib/uwufetch/ascii/%s.txt", user_info->os_name);
+    else
+      sprintf(ascii_file, "/usr/lib/uwufetch/ascii/%s.txt", user_info->os_name);
+    LOG_V(ascii_file);
+
+    file = fopen(ascii_file, "r");
+    if (!file) {
+      // Prevent infinite loops
+      if (strcmp(user_info->os_name, "unknown") == 0) {
+        LOG_E("No\nunknown\nascii\nfile\n\n\n\n");
+        return 7;
+      }
+      sprintf(user_info->os_name, "unknown"); // current os is not supported
+      LOG_V(user_info->os_name);
+      return print_ascii(user_info);
+    }
+  }
+  char buffer[256]; // line buffer
+  int line_count = 1;
+  printf("\n");
+  while (fgets(buffer, 256, file)) { // replacing color placecholders
+    replace(buffer, "{NORMAL}", NORMAL);
+    replace(buffer, "{BOLD}", BOLD);
+    replace(buffer, "{BLACK}", BLACK);
+    replace(buffer, "{RED}", RED);
+    replace(buffer, "{GREEN}", GREEN);
+    replace(buffer, "{SPRING_GREEN}", SPRING_GREEN);
+    replace(buffer, "{YELLOW}", YELLOW);
+    replace(buffer, "{BLUE}", BLUE);
+    replace(buffer, "{MAGENTA}", MAGENTA);
+    replace(buffer, "{CYAN}", CYAN);
+    replace(buffer, "{WHITE}", WHITE);
+    replace(buffer, "{PINK}", PINK);
+    replace(buffer, "{LPINK}", LPINK);
+    replace(buffer, "{BLOCK}", BLOCK_CHAR);
+    replace(buffer, "{BLOCK_VERTICAL}", BLOCK_CHAR);
+    replace(buffer, "{BACKGROUND_GREEN}", "\e[0;42m");
+    replace(buffer, "{BACKGROUND_RED}", "\e[0;41m");
+    replace(buffer, "{BACKGROUND_WHITE}", "\e[0;47m");
+    printf("%s", buffer); // print the line after setting the color
+    line_count++;
+  }
+  // Always set color to NORMAL, so there's no need to do this in every ascii file.
+  printf(NORMAL);
+  fclose(file);
+  return line_count;
 }
 
 /* prints distribution list
-	 distributions are listed by distribution branch
-	 to make the output easier to understand by the user.*/
+   distributions are listed by distribution branch
+   to make the output easier to understand by the user.*/
 void list(char* arg) {
-	LOG_I("printing supported distro list");
-	// clang-format off
+  LOG_I("printing supported distro list");
+  // clang-format off
 	printf("%s -d <options>\n"
 				 "  Available distributions:\n"
 				 "    "BLUE"Arch linux "NORMAL"based:\n"
-				 "      "BLUE"arch, arcolinux, "MAGENTA"artix, endeavouros "GREEN"manjaro, manjaro-arm, "BLUE"xerolinux\n\n"
+				 "      "BLUE"arch, arcolinux, "MAGENTA"artix, endeavouros "GREEN"manjaro, manjaro-arm, "BLUE"xerolinux, "MAGENTA"menheraos\n\n"
 				 "    "RED"Debian/"YELLOW"Ubuntu "NORMAL"based:\n"
 				 "      "RED"amogos, debian, deepin, "GREEN"linuxmint, neon, "BLUE"pop, "RED"raspbian "YELLOW"ubuntu\n\n"
 				 "    "RED"BSD "NORMAL"based:\n"
@@ -639,152 +683,154 @@
 				 "    "NORMAL"Other/spare distributions:\n"
 				 "      "BLUE"alpine, "PINK"femboyos, gentoo, "MAGENTA"slackware, "WHITE"solus, "GREEN"void, opensuse-leap, android, "YELLOW"gnu, guix, "BLUE"windows, "WHITE"unknown\n\n",
 				 arg); // Other/spare distributions colors
-	// clang-format on
+  // clang-format on
 }
 
 // prints the usage
 void usage(char* arg) {
-	LOG_I("printing usage");
-	printf("Usage: %s <args>\n"
-				 "    -c  --config        use custom config path\n"
-				 "    -d, --distro        lets you choose the logo to print\n"
-				 "    -h, --help          prints this help page\n"
+  LOG_I("printing usage");
+  printf("Usage: %s <args>\n"
+         "    -c  --config        use custom config path\n"
+         "    -d, --distro        lets you choose the logo to print\n"
+         "    -h, --help          prints this help page\n"
 #ifndef __IPHONE__
-				 "    -i, --image         prints logo as image and use a custom image "
-				 "if provided\n"
-				 "                        %sworks in most terminals\n"
+         "    -i, --image         prints logo as image and use a custom image "
+         "if provided\n"
+         "                        %sworks in most terminals\n"
 #else
-				 "    -i, --image         prints logo as image and use a custom image "
-				 "if provided\n"
-				 "                        %sdisabled under iOS\n"
-#endif
-				 "                        read README.md for more info%s\n"
-				 "    -l, --list          lists all supported distributions\n"
-				 "    -V, --version       prints the current uwufetch version\n"
+         "    -i, --image         prints logo as image and use a custom image "
+         "if provided\n"
+         "                        %sdisabled under iOS\n"
+#endif
+         "                        read README.md for more info%s\n"
+         "    -l, --list          lists all supported distributions\n"
+         "    -V, --version       prints the current uwufetch version\n"
 #ifdef __DEBUG__
-				 "    -v, --verbose       logs everything\n"
+         "    -v, --verbose       logs everything\n"
 #endif
-				 "    -w, --write-cache   writes to the cache file (~/.cache/uwufetch.cache)\n"
-				 "    -r, --read-cache    reads from the cache file (~/.cache/uwufetch.cache)\n",
-				 arg,
+         "    -w, --write-cache   writes to the cache file (~/.cache/uwufetch.cache)\n"
+         "    -r, --read-cache    reads from the cache file (~/.cache/uwufetch.cache)\n",
+         arg,
 #ifndef __IPHONE__
-				 BLUE,
+         BLUE,
 #else
-				 RED,
+         RED,
 #endif
-				 NORMAL);
+         NORMAL);
 }
 
 // the main function is on the bottom of the file to avoid double function declarations
 int main(int argc, char* argv[]) {
 #ifdef __DEBUG__
-	verbose_enabled = get_verbose_handle();
+  verbose_enabled = get_verbose_handle();
 #endif
-	struct user_config user_config_file = {0};
-	struct info user_info								= {0};
-	struct configuration config_flags		= parse_config(&user_info, &user_config_file);
-	char* custom_distro_name						= NULL;
-	char* custom_image_name							= NULL;
+  struct user_config user_config_file = {0};
+  struct info user_info               = {0};
+  struct configuration config_flags   = parse_config(&user_info, &user_config_file);
+  char* custom_distro_name            = NULL;
+  char* custom_image_name             = NULL;
 
 #ifdef _WIN32
-	// packages disabled by default because chocolatey is too slow
-	config_flags.show.pkgs = 0;
+  // packages disabled by default because chocolatey is too slow
+  config_flags.show.pkgs = 0;
 #endif
 
-	int opt											 = 0;
-	struct option long_options[] = {
-			{"config", required_argument, NULL, 'c'},
-			{"distro", required_argument, NULL, 'd'},
-			{"help", no_argument, NULL, 'h'},
-			{"image", optional_argument, NULL, 'i'},
-			{"list", no_argument, NULL, 'l'},
-			{"read-cache", no_argument, NULL, 'r'},
-			{"version", no_argument, NULL, 'V'},
+  int opt                      = 0;
+  struct option long_options[] = {
+      {"config", required_argument, NULL, 'c'},
+      {"distro", required_argument, NULL, 'd'},
+      {"help", no_argument, NULL, 'h'},
+      {"image", optional_argument, NULL, 'i'},
+      {"list", no_argument, NULL, 'l'},
+      {"read-cache", no_argument, NULL, 'r'},
+      {"version", no_argument, NULL, 'V'},
 #ifdef __DEBUG__
-			{"verbose", no_argument, NULL, 'v'},
+      {"verbose", no_argument, NULL, 'v'},
 #endif
-			{"write-cache", no_argument, NULL, 'w'},
-			{0}};
+      {"write-cache", no_argument, NULL, 'w'},
+      {0}};
 #ifdef __DEBUG__
-	#define OPT_STRING "c:d:hi::lrVvw"
+  #define OPT_STRING "c:d:hi::lrVvw"
 #else
-	#define OPT_STRING "c:d:hi::lrVw"
+  #define OPT_STRING "c:d:hi::lrVw"
 #endif
 
-	// reading cmdline options
-	while ((opt = getopt_long(argc, argv, OPT_STRING, long_options, NULL)) != -1) {
-		switch (opt) {
-		case 'c': // set the config directory
-			user_config_file.config_directory = optarg;
-			config_flags											= parse_config(&user_info, &user_config_file);
-			break;
-		case 'd': // set the distribution name
-			custom_distro_name = optarg;
-			break;
-		case 'h':
-			usage(argv[0]);
-			return 0;
-		case 'i': // set ascii logo as output
-			config_flags.show_image = true;
-			if (argv[optind]) custom_image_name = argv[optind];
-			break;
-		case 'l':
-			list(argv[0]);
-			return 0;
-		case 'r':
-			user_config_file.read_enabled = true;
-			break;
-		case 'V':
-			printf("UwUfetch version %s\n", UWUFETCH_VERSION);
-			return 0;
+  // reading cmdline options
+  while ((opt = getopt_long(argc, argv, OPT_STRING, long_options, NULL)) != -1) {
+    switch (opt) {
+    case 'c': // set the config directory
+      user_config_file.config_directory = optarg;
+      config_flags                      = parse_config(&user_info, &user_config_file);
+      break;
+    case 'd': // set the distribution name
+      custom_distro_name = optarg;
+      break;
+    case 'h':
+      usage(argv[0]);
+      return 0;
+    case 'i': // set ascii logo as output
+      config_flags.show_image = true;
+      if (argv[optind]) custom_image_name = argv[optind];
+      break;
+    case 'l':
+      list(argv[0]);
+      return 0;
+    case 'r':
+      user_config_file.read_enabled = true;
+      break;
+    case 'V':
+      printf("UwUfetch version %s\n", UWUFETCH_VERSION);
+      return 0;
 #ifdef __DEBUG__
-		case 'v':
-			*verbose_enabled = true;
-			LOG_I("version %s", UWUFETCH_VERSION);
-			break;
-#endif
-		case 'w':
-			user_config_file.write_enabled = true;
-			break;
-		default:
-			return 1;
-		}
-	}
-
-	if (user_config_file.read_enabled) {
-		// if no cache file found write to it
-		if (!read_cache(&user_info)) {
-			user_config_file.read_enabled	 = false;
-			user_config_file.write_enabled = true;
-		} else {
-			int buf_sz = 256;
-			char buffer[buf_sz]; // line buffer
-			struct thread_varg vargp = {
-					buffer, &user_info, NULL, {true, true, true, true, true, true, true, true}};
-			if (config_flags.show.ram) get_ram(&vargp);
-			if (config_flags.show.uptime) {
-				LOG_I("getting additional not-cached info");
-				get_sys(&user_info);
-				get_upt(&vargp);
-			}
-		}
-	}
-	if (!user_config_file.read_enabled)
-		get_info(config_flags.show, &user_info);
-
-	if (user_config_file.write_enabled) {
-		write_cache(&user_info);
-	}
-	if (custom_distro_name) sprintf(user_info.os_name, "%s", custom_distro_name);
-	if (custom_image_name) sprintf(user_info.image_name, "%s", custom_image_name);
-
-	uwufy_all(&user_info);
-
-	// print ascii or image and align cursor for print_info()
-	printf("\033[%dA", config_flags.show_image ? print_image(&user_info) : print_ascii(&user_info));
-
-	// print info and move cursor down if the number of printed lines is smaller that the default image height
-	printf("\033[%dB", 9 - print_info(&config_flags, &user_info));
-	LOG_I("Execution completed successfully!");
-	return 0;
+    case 'v':
+      *verbose_enabled = true;
+      LOG_I("version %s", UWUFETCH_VERSION);
+      break;
+#endif
+    case 'w':
+      user_config_file.write_enabled = true;
+      break;
+    default:
+      return 1;
+    }
+  }
+
+  if (user_config_file.read_enabled) {
+    // if no cache file found write to it
+    if (!read_cache(&user_info)) {
+      user_config_file.read_enabled  = false;
+      user_config_file.write_enabled = true;
+    } else {
+      int buf_sz = 256;
+      char buffer[buf_sz]; // line buffer
+      struct thread_varg vargp = {
+          buffer, &user_info, NULL, {true, true, true, true, true, true, true, true}};
+      if (config_flags.show.ram) get_ram(&vargp);
+      if (config_flags.show.uptime) {
+        LOG_I("getting additional not-cached info");
+        get_sys(&user_info);
+        get_upt(&vargp);
+      }
+    }
+  }
+  if (!user_config_file.read_enabled)
+    get_info(config_flags.show, &user_info);
+  LOG_V(user_info.gpu_model[1]);
+
+  if (user_config_file.write_enabled) {
+    write_cache(&user_info);
+  }
+  if (custom_distro_name) sprintf(user_info.os_name, "%s", custom_distro_name);
+  if (custom_image_name) sprintf(user_info.image_name, "%s", custom_image_name);
+
+  uwufy_all(&user_info);
+
+  // print ascii or image and align cursor for print_info()
+  printf("\033[%dA", config_flags.show_image ? print_image(&user_info) : print_ascii(&user_info));
+
+  // print info and move cursor down if the number of printed lines is smaller that the default image height
+  int to_move = 9 - print_info(&config_flags, &user_info);
+  printf("\033[%d%c", to_move < 0 ? -to_move : to_move, to_move < 0 ? 'A' : 'B');
+  LOG_I("Execution completed successfully!");
+  return 0;
 }
